@inject IChannelMessageService MessageService
@inject ISnackbar Snackbar
@inject UserState UserState

<div class="message-item @(_isOwnMessage ? "own-message" : "") @(_message.IsPinned ? "pinned-message" : "")"
     style="animation: fadeIn 0.3s ease-out;">

    @if (_message.IsPinned)
    {
        <div class="pinned-indicator">
            <MudIcon Icon="@Icons.Material.Filled.PushPin" Size="Size.Small" />
            <MudText Typo="Typo.Caption">Pinned</MudText>
        </div>
    }

    <div class="message-header d-flex align-items-center gap-2 mb-1">
        <MudAvatar Color="Color.Primary" Size="Size.Small">
            @_message.SenderName.Substring(0, 1).ToUpper()
        </MudAvatar>

        <MudText Typo="Typo.Subtitle2" Class="font-weight-bold">
            @_message.SenderName
        </MudText>

        <MudText Typo="Typo.Caption" Color="Color.Secondary">
            @_message.SentAtUtc.ToLocalTime().ToString("HH:mm")
            @if (_message.IsEdited)
            {
                <span class="ml-1">(edited)</span>
            }
        </MudText>

        <MudSpacer />

        @if (_isOwnMessage || CanManageMessages)
        {
            <MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Dense="true">
                @if (_isOwnMessage)
                {
                    <MudMenuItem Icon="@Icons.Material.Filled.Edit" OnClick="StartEdit">Edit</MudMenuItem>
                }
                @if (CanManageMessages)
                {
                    <MudMenuItem Icon="@Icons.Material.Filled.PushPin"
                                 OnClick="TogglePin">
                        @(_message.IsPinned ? "Unpin" : "Pin")
                    </MudMenuItem>
                }
                @if (_isOwnMessage || CanManageMessages)
                {
                    <MudMenuItem Icon="@Icons.Material.Filled.Delete"
                                 OnClick="DeleteMessage"
                                 Class="text-error">
                        Delete
                    </MudMenuItem>
                }
            </MudMenu>
        }
    </div>

    <div class="message-content">
        @if (_isEditing)
        {
            <div class="edit-box">
                <MudTextField @bind-Value="_editContent"
                              Lines="3"
                              Variant="Variant.Outlined"
                              Margin="Margin.Dense"
                              Class="mb-2" />
                <div class="d-flex gap-2">
                    <MudButton Size="Size.Small"
                               Variant="Variant.Filled"
                               Color="Color.Primary"
                               OnClick="SaveEdit"
                               Disabled="@_isUpdating">
                        Save
                    </MudButton>
                    <MudButton Size="Size.Small"
                               Variant="Variant.Text"
                               OnClick="CancelEdit">
                        Cancel
                    </MudButton>
                </div>
            </div>
        }
        else
        {
            <MudText Typo="Typo.Body2" Style="white-space: pre-wrap;">
                @_message.Content
            </MudText>
        }
    </div>

    @if (_message.Reactions.Any())
    {
        <div class="reactions d-flex flex-wrap gap-1 mt-2">
            @foreach (var reaction in _message.Reactions.GroupBy(r => r.Emoji))
            {
                var isUserReaction = reaction.Any(r => r.UserId == UserState.CurrentUser?.Id);
                <MudChip Size="Size.Small"
                         Color="@(isUserReaction ? Color.Primary : Color.Default)"
                         Variant="@(isUserReaction ? Variant.Filled : Variant.Outlined)"
                         OnClick="@(() => ToggleReaction(reaction.Key))"
                         Class="reaction-chip">
                    @reaction.Key @reaction.Count()
                </MudChip>
            }
        </div>
    }

    <div class="mt-1">
        <MudButton StartIcon="@Icons.Material.Outlined.AddReaction"
                   Size="Size.Small"
                   Variant="Variant.Text"
                   OnClick="OpenReactionPicker">
            Add Reaction
        </MudButton>
    </div>
</div>

<style>
    .message-item {
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 8px;
        transition: background-color 0.2s;
    }

    .message-item:hover {
        background-color: rgba(0, 0, 0, 0.02);
    }

    .own-message {
        background-color: rgba(var(--mud-palette-primary-rgb), 0.05);
    }

    .pinned-message {
        border-left: 3px solid var(--mud-palette-warning);
    }

    .pinned-indicator {
        display: flex;
        align-items: center;
        gap: 4px;
        color: var(--mud-palette-warning);
        margin-bottom: 4px;
    }

    .reaction-chip {
        cursor: pointer;
        transition: transform 0.2s;
    }

    .reaction-chip:hover {
        transform: scale(1.1);
    }
</style>

@code {
    [Parameter] public ChannelMessageDto Message { get; set; } = null!;
    [Parameter] public Guid ChannelId { get; set; }
    [Parameter] public bool CanManageMessages { get; set; }
    [Parameter] public EventCallback OnMessageChanged { get; set; }

    private ChannelMessageDto _message = null!;
    private bool _isOwnMessage = false;
    private bool _isEditing = false;
    private bool _isUpdating = false;
    private string _editContent = string.Empty;

    // Simple emoji picker options
    private readonly string[] _emojis = { "ðŸ‘", "â¤ï¸", "ðŸ˜‚", "ðŸ˜®", "ðŸ˜¢", "ðŸŽ‰", "ðŸš€", "ðŸ‘€" };

    protected override void OnParametersSet()
    {
        _message = Message;
        _isOwnMessage = _message.SenderId == UserState.CurrentUser?.Id;
    }

    private void StartEdit()
    {
        _editContent = _message.Content;
        _isEditing = true;
    }

    private void CancelEdit()
    {
        _isEditing = false;
        _editContent = string.Empty;
    }

    private async Task SaveEdit()
    {
        if (string.IsNullOrWhiteSpace(_editContent)) return;

        _isUpdating = true;

        var request = new EditMessageRequest { NewContent = _editContent.Trim() };
        var result = await MessageService.EditMessageAsync(ChannelId, _message.Id, request);

        _isUpdating = false;

        if (result.IsSuccess)
        {
            _isEditing = false;
            Snackbar.Add("Message updated", Severity.Success);
            await OnMessageChanged.InvokeAsync();
        }
        else
        {
            Snackbar.Add(result.Error ?? "Failed to update message", Severity.Error);
        }
    }

    private async Task DeleteMessage()
    {
        var result = await MessageService.DeleteMessageAsync(ChannelId, _message.Id);

        if (result.IsSuccess)
        {
            Snackbar.Add("Message deleted", Severity.Success);
            await OnMessageChanged.InvokeAsync();
        }
        else
        {
            Snackbar.Add(result.Error ?? "Failed to delete message", Severity.Error);
        }
    }

    private async Task TogglePin()
    {
        Result result;

        if (_message.IsPinned)
        {
            result = await MessageService.UnpinMessageAsync(ChannelId, _message.Id);
        }
        else
        {
            result = await MessageService.PinMessageAsync(ChannelId, _message.Id);
        }

        if (result.IsSuccess)
        {
            Snackbar.Add(_message.IsPinned ? "Message unpinned" : "Message pinned", Severity.Success);
            await OnMessageChanged.InvokeAsync();
        }
        else
        {
            Snackbar.Add(result.Error ?? "Failed to update pin status", Severity.Error);
        }
    }

    private async Task OpenReactionPicker()
    {
        // Simple implementation - cycle through common emojis
        // In a full implementation, you'd show a proper emoji picker dialog
        await ToggleReaction("ðŸ‘");
    }

    private async Task ToggleReaction(string emoji)
    {
        var hasReaction = _message.Reactions.Any(r =>
            r.UserId == UserState.CurrentUser?.Id && r.Emoji == emoji);

        Result result;

        if (hasReaction)
        {
            var request = new RemoveReactionRequest { Emoji = emoji };
            result = await MessageService.RemoveReactionAsync(ChannelId, _message.Id, request);
        }
        else
        {
            var request = new AddReactionRequest { Emoji = emoji };
            result = await MessageService.AddReactionAsync(ChannelId, _message.Id, request);
        }

        if (result.IsSuccess)
        {
            await OnMessageChanged.InvokeAsync();
        }
        else
        {
            Snackbar.Add(result.Error ?? "Failed to update reaction", Severity.Error);
        }
    }
}
