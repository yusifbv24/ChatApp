@inject IJSRuntime JS
@using ChatApp.Blazor.Client.Models.Messages

<div id="message-@MessageId" class="message-wrapper @(IsOwn ? "own" : "other") @(IsDeleted ? "deleted" : "") @(!IsDirectMessage && !IsOwn ? "group-message" : "") @(IsSelectMode ? "select-mode" : "")" @ref="messageWrapperRef">

    @* Selection checkbox - visible only in select mode and not for deleted messages *@
    @if (IsSelectMode && !IsDeleted)
    {
        <div class="message-select-checkbox @(IsSelected ? "selected" : "")" @onclick="HandleBubbleClick" @onclick:stopPropagation="true">
            @if (IsSelected)
            {
                <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Medium" Class="checkbox-icon" />
            }
            else
            {
                <div class="checkbox-empty"></div>
            }
        </div>
    }

    @if (!IsOwn && !IsDirectMessage)
    {
        <!-- Always show avatar space for group messages to maintain alignment -->
        <div class="message-avatar @(!ShowAvatar ? "avatar-spacer" : "")">
            @if (ShowAvatar)
            {
                @if (!string.IsNullOrEmpty(AvatarUrl))
                {
                    <img src="@AvatarUrl" alt="@SenderName" />
                }
                else
                {
                    <div class="avatar-placeholder">@GetInitials(SenderName)</div>
                }
            }
        </div>
    }

    <div class="message-content-wrapper">
        @if (!IsOwn && ShowSenderName)
        {
            <div class="message-sender">@SenderName</div>
        }
        <div class="message-bubble @(IsOwn ? "own-bubble" : "other-bubble") @(IsSelectMode && !IsDeleted ? "selectable" : "")"
             @onmouseenter="() => showHoverActions = true"
             @onmouseleave="() => { if (!showMoreMenu && !showReactionPicker) showHoverActions = false; }"
             @onclick="HandleBubbleClick">
            @if (IsDeleted)
            {
                <div class="deleted-message">
                    <MudIcon Icon="@Icons.Material.Filled.Block" Size="Size.Small" />
                    <span>This message was deleted</span>
                </div>
            }
            else
            {
                <div class="message-content-block">
                    @* Show forwarded indicator *@
                    @if (IsForwarded)
                    {
                        <div class="forwarded-label">
                            <MudIcon Icon="@Icons.Material.Filled.Forward" Size="Size.Small" />
                            <span>Forwarded</span>
                        </div>
                    }

                    @* Show replied message preview if this is a reply *@
                    @if (!string.IsNullOrEmpty(ReplyToContent))
                    {
                        <div class="reply-preview clickable" @onclick="HandleReplyClick">
                            <div class="reply-bar"></div>
                            <div class="reply-content">
                                <div class="reply-sender">@ReplyToSenderName</div>
                                <div class="reply-text">@TruncateText(ReplyToContent, 50)</div>
                            </div>
                        </div>
                    }

                    <!-- Message text -->
                    <div class="message-text">@Content</div>

                    <!-- Footer Row: Reactions (left) and Time/Status (right) -->
                    <div class="message-footer-row">
                        <!-- Reactions - parallel to footer -->
                        @if (GetReactionsList() is var reactions && reactions != null && reactions.Count > 0 && !IsDeleted)
                        {
                            <div class="message-reactions-inline">
                                @foreach (var reaction in reactions)
                                {
                                    var reactionIndex = reactions.IndexOf(reaction);
                                    var isOwnReaction = CurrentUserId.HasValue && reaction.UserIds.Contains(CurrentUserId.Value);
                                    var badgeClass = isOwnReaction ? "reaction-badge own-reaction" : "reaction-badge";

                                    @if (!IsDirectMessage)
                                    {
                                        @* Channel messages - show user panel on hover *@
                                        <span class="@badgeClass reaction-badge-wrapper"
                                              @onclick="() => SelectReaction(reaction.Emoji)"
                                              @onmouseenter="() => ShowReactionUsers(reactionIndex)"
                                              @onmouseleave="ScheduleHideReactionUsers">
                                            <span class="reaction-emoji">@reaction.Emoji</span>
                                            <span class="reaction-count">@reaction.Count</span>

                                            @* User panel popup *@
                                            @if (hoveredReactionIndex == reactionIndex)
                                            {
                                                <div class="reaction-users-panel"
                                                     @onclick:stopPropagation="true"
                                                     @onmouseenter="CancelHideReactionUsers"
                                                     @onmouseleave="ScheduleHideReactionUsers">
                                                    @for (int i = 0; i < reaction.UserDisplayNames.Count; i++)
                                                    {
                                                        var displayName = reaction.UserDisplayNames[i];
                                                        var avatarUrl = reaction.UserAvatarUrls[i];
                                                        <div class="reaction-user-item">
                                                            <div class="reaction-user-avatar">
                                                                @if (!string.IsNullOrEmpty(avatarUrl))
                                                                {
                                                                    <img src="@avatarUrl" alt="@displayName" />
                                                                }
                                                                else
                                                                {
                                                                    <div class="avatar-placeholder-small">@GetInitials(displayName)</div>
                                                                }
                                                            </div>
                                                            <span class="reaction-user-name">@displayName</span>
                                                        </div>
                                                    }
                                                </div>
                                            }
                                        </span>
                                    }
                                    else
                                    {
                                        @* Direct messages - no user panel on hover *@
                                        <span class="@badgeClass reaction-badge-wrapper"
                                              @onclick="() => SelectReaction(reaction.Emoji)">
                                            <span class="reaction-emoji">@reaction.Emoji</span>
                                            <span class="reaction-count">@reaction.Count</span>
                                        </span>
                                    }
                                }
                            </div>
                        }

                        <!-- Footer: Time and status -->
                        <div class="message-footer">
                            @if (IsEdited)
                            {
                                <span class="edited-label">edited</span>
                            }
                            @if (IsPinned)
                            {
                                <MudIcon Icon="@Icons.Material.Filled.PushPin" Size="Size.Small" Class="pinned-icon-inline" />
                            }
                            <span class="message-time">@FormatTime(CreatedAt)</span>
                            @if (IsOwn && !IsDeleted)
                            {
                                @if (IsDirectMessage)
                                {
                                    <span class="read-status">
                                        @if (IsRead)
                                        {
                                            <MudIcon Icon="@Icons.Material.Filled.DoneAll" Size="Size.Small" Class="read-icon" />
                                        }
                                        else
                                        {
                                            <MudIcon Icon="@Icons.Material.Filled.Done" Size="Size.Small" />
                                        }
                                    </span>
                                }
                                else
                                {
                                    @* Channel message read status *@
                                    <span class="read-status">
                                        @if (ReadByCount > 0)
                                        {
                                            @* At least one person read it - show double checkmark *@
                                            @* Blue if everyone (except sender) read it, gray if only some read it *@
                                            @* TotalMemberCount already excludes sender (calculated in backend) *@
                                            <MudIcon Icon="@Icons.Material.Filled.DoneAll" Size="Size.Small"
                                                     Class="@(TotalMemberCount > 0 && ReadByCount >= TotalMemberCount ? "read-icon" : "")" />
                                        }
                                        else
                                        {
                                            @* Not read by anyone - show single checkmark *@
                                            <MudIcon Icon="@Icons.Material.Filled.Done" Size="Size.Small" />
                                        }
                                    </span>
                                }
                            }
                        </div>
                    </div>
                </div>
            }

            <!-- Chevron button - top right corner (visible for both deleted and normal messages) -->
            @if (!IsSelectMode && (showHoverActions || showMoreMenu))
            {
                <button class="chevron-more-btn @(showMoreMenu ? "visible" : "")"
                        title="More"
                        @onclick="ToggleMoreMenu"
                        @onclick:stopPropagation="true">
                    <MudIcon Icon="@Icons.Material.Filled.KeyboardArrowDown" Size="Size.Small" />
                </button>
            }

            <!-- More Menu (content depends on IsDeleted) -->
            @if (showMoreMenu)
            {
                <div class="chevron-more-menu @(menuPositionAbove ? "menu-above" : "")" @onclick:stopPropagation="true">
                    @if (IsDeleted)
                    {
                        @* Deleted messages: ONLY Reply is allowed *@
                        <button class="menu-item" @onclick="HandleReplyButtonClick">
                            <span>Reply</span>
                            <MudIcon Icon="@Icons.Material.Outlined.FormatQuote" Size="Size.Small" />
                        </button>
                    }
                    else
                    {
                        @* Normal messages: Full menu *@
                        <button class="menu-item" @onclick="HandleReplyButtonClick">
                            <span>Reply</span>
                            <MudIcon Icon="@Icons.Material.Outlined.FormatQuote" Size="Size.Small" />
                        </button>
                        <button class="menu-item" @onclick="OnCopyClick">
                            <span>Copy</span>
                            <MudIcon Icon="@Icons.Material.Outlined.ContentCopy" Size="Size.Small" />
                        </button>
                        @if (IsOwn && !IsForwarded)
                        {
                            <button class="menu-item" @onclick="OnEditClick">
                                <span>Edit</span>
                                <MudIcon Icon="@Icons.Material.Outlined.Edit" Size="Size.Small" />
                            </button>
                        }
                        <button class="menu-item" @onclick="OnForwardClick">
                            <span>Forward</span>
                            <MudIcon Icon="@Icons.Material.Outlined.Redo" Size="Size.Small" />
                        </button>
                        <button class="menu-item" @onclick="OnPinClick">
                            <span>@(IsPinned ? "Unpin" : "Pin")</span>
                            <MudIcon Icon="@(IsPinned ? Icons.Material.Outlined.PushPin : Icons.Material.Outlined.PushPin)" Size="Size.Small" />
                        </button>
                        <button class="menu-item" @onclick="HandleAddToFavoritesClick">
                            <span>Add to Favorites</span>
                            <MudIcon Icon="@Icons.Material.Outlined.StarBorder" Size="Size.Small" />
                        </button>
                        @if (!IsMarkedAsLater)
                        {
                            @* Mark as Later - for both channel and conversation messages, not already marked *@
                            <button class="menu-item" @onclick="HandleMarkAsLaterClick">
                                <span>Mark as Later</span>
                                <MudIcon Icon="@Icons.Material.Outlined.WatchLater" Size="Size.Small" />
                            </button>
                        }
                        @if (IsOwn)
                        {
                            <button class="menu-item delete-item" @onclick="OnDeleteClick">
                                <span>Delete</span>
                                <MudIcon Icon="@Icons.Material.Outlined.Delete" Size="Size.Small" />
                            </button>
                        }
                        <button class="menu-item" @onclick="HandleSelectClick">
                            <span>Select</span>
                            <MudIcon Icon="@Icons.Material.Outlined.CheckCircle" Size="Size.Small" />
                        </button>
                    }
                </div>
            }

            <!-- Quick Reaction Icon (Like button in bottom corner) - hidden for deleted messages and select mode -->
            @if (!IsSelectMode && !IsDeleted && (showHoverActions || showReactionPicker))
            {
                <div class="reaction-quick-icon @(showReactionPicker ? "active" : "")"
                     @onmouseenter="HandleReactionIconHover"
                     @onmouseleave="CancelReactionIconHover"
                     @onclick="ToggleLikeReaction"
                     @onclick:stopPropagation="true">
                    <span class="quick-icon-emoji">👍</span>

                    @if (showReactionPicker)
                    {
                        <div class="reaction-picker-quick"
                             @onmouseenter="KeepReactionPickerOpen"
                             @onmouseleave="HandleReactionPickerLeave"
                             @onclick:stopPropagation="true">
                            @foreach (var emoji in CommonReactions)
                            {
                                <button class="reaction-btn" @onclick="() => SelectReaction(emoji)">@emoji</button>
                            }
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    <!-- More Menu Overlay -->
    @if (showMoreMenu)
    {
        <div class="popup-overlay" @onclick="CloseMoreMenu"></div>
    }
</div>

@code {
    [Parameter] public Guid MessageId { get; set; }
    [Parameter] public string Content { get; set; } = "";
    [Parameter] public string SenderName { get; set; } = "";
    [Parameter] public string? AvatarUrl { get; set; }
    [Parameter] public DateTime CreatedAt { get; set; }
    [Parameter] public bool IsOwn { get; set; }
    [Parameter] public bool IsEdited { get; set; }
    [Parameter] public bool IsDeleted { get; set; }
    [Parameter] public bool IsRead { get; set; }
    [Parameter] public int ReadByCount { get; set; }
    [Parameter] public int TotalMemberCount { get; set; }
    [Parameter] public bool IsPinned { get; set; }
    [Parameter] public int ReactionCount { get; set; }
    [Parameter] public object? Reactions { get; set; } // Can be List<MessageReactionDto> or List<ChannelMessageReactionDto>
    [Parameter] public Guid? CurrentUserId { get; set; }
    [Parameter] public bool ShowAvatar { get; set; }
    [Parameter] public bool ShowSenderName { get; set; }
    [Parameter] public bool IsDirectMessage { get; set; }

    // Reply-related parameters
    [Parameter] public Guid? ReplyToMessageId { get; set; }
    [Parameter] public string? ReplyToContent { get; set; }
    [Parameter] public string? ReplyToSenderName { get; set; }
    [Parameter] public bool IsForwarded { get; set; }
    [Parameter] public EventCallback OnEdit { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback<string> OnReaction { get; set; }
    [Parameter] public EventCallback OnReply { get; set; }
    [Parameter] public EventCallback OnPin { get; set; }
    [Parameter] public EventCallback OnForward { get; set; }
    [Parameter] public EventCallback<Guid> OnReplyClick { get; set; }
    [Parameter] public EventCallback OnActionCompleted{ get; set; }
    [Parameter] public EventCallback ScrollToBottom{ get; set; }
    [Parameter] public Guid? LastReadLaterMessageId { get; set; }
    [Parameter] public EventCallback<Guid> OnMarkAsLater { get; set; }

    // Selection mode parameters
    [Parameter] public bool IsSelectMode { get; set; }
    [Parameter] public bool IsSelected { get; set; }
    [Parameter] public EventCallback<Guid> OnSelectToggle { get; set; }

    private ElementReference messageWrapperRef;
    private bool showReactionPicker = false;
    private bool showMoreMenu = false;
    private bool showHoverActions = false;
    private bool menuPositionAbove = false;
    private int? hoveredReactionIndex = null;
    private CancellationTokenSource? hideReactionPanelCts;
    private readonly string[] CommonReactions = { "👍", "❤️", "😂", "😮", "😢", "🎉" };

    private string GetInitials(string name)
    {
        if (string.IsNullOrEmpty(name)) return "?";
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length >= 2
            ? $"{parts[0][0]}{parts[1][0]}".ToUpper()
            : name[0].ToString().ToUpper();
    }

    private string FormatTime(DateTime dateTime)
    {
        return dateTime.ToLocalTime().ToString("HH:mm", System.Globalization.CultureInfo.InvariantCulture);
    }

    private string TruncateText(string? text, int maxLength)
    {
        if (string.IsNullOrEmpty(text)) return "";
        if (text.Length <= maxLength) return text;
        return text.Substring(0, maxLength) + "...";
    }

    private async Task OnEditClick()
    {
        CloseMoreMenu();
        await OnEdit.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
        await ScrollToBottom.InvokeAsync();
    }

    private async Task OnDeleteClick()
    {
        CloseMoreMenu();
        await OnDelete.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private CancellationTokenSource? showReactionPickerCts;

    private async Task HandleReactionIconHover()
    {
        // Cancel any existing delay
        showReactionPickerCts?.Cancel();
        showReactionPickerCts = new CancellationTokenSource();
        var token = showReactionPickerCts.Token;

        try
        {
            // Wait 250ms before showing picker
            await Task.Delay(250, token);

            if (!token.IsCancellationRequested)
            {
                showReactionPicker = true;
                showMoreMenu = false;
                StateHasChanged();
            }
        }
        catch (TaskCanceledException)
        {
            // Expected when hovering away quickly
        }
    }

    private async Task CancelReactionIconHover()
    {
        // Small delay before closing picker
        showReactionPickerCts?.Cancel();
        showReactionPickerCts = new CancellationTokenSource();
        var token = showReactionPickerCts.Token;

        try
        {
            await Task.Delay(200, token);

            if (!token.IsCancellationRequested)
            {
                showReactionPicker = false;
                StateHasChanged();
            }
        }
        catch (TaskCanceledException) { }
    }

    private Task KeepReactionPickerOpen()
    {
        // Cancel any scheduled close operation to keep picker open
        showReactionPickerCts?.Cancel();
        showReactionPickerCts = null;
        return Task.CompletedTask;
    }

    private async Task HandleReactionPickerLeave()
    {
        // Small delay before closing picker
        showReactionPickerCts?.Cancel();
        showReactionPickerCts = new CancellationTokenSource();
        var token = showReactionPickerCts.Token;

        try
        {
            await Task.Delay(200, token);

            if (!token.IsCancellationRequested)
            {
                showReactionPicker = false;
                StateHasChanged();
            }
        }
        catch (TaskCanceledException) { }
    }

    private async Task ToggleLikeReaction()
    {
        // Immediately close picker (don't wait for delay)
        showReactionPickerCts?.Cancel();
        showReactionPicker = false;

        // Toggle like reaction
        await OnReaction.InvokeAsync("👍");
        await OnActionCompleted.InvokeAsync();
    }

    private async Task ToggleMoreMenu()
    {
        if (!showMoreMenu)
        {
            // Check if menu should appear above or below
            await CheckMenuPosition();
        }
        showMoreMenu = !showMoreMenu;
        showReactionPicker = false;
    }

    private async Task CheckMenuPosition()
    {
        try
        {
            var position = await JS.InvokeAsync<MenuPositionInfo>("chatAppUtils.getElementPosition", messageWrapperRef);
            if (position != null)
            {
                // Menu can have up to 9 items: Reply, Copy, Edit, Forward, Pin, Add to Favorites, Mark to read later, Delete, Select
                // Each item is ~42px height (11px padding top + 11px bottom + ~20px content)
                // Maximum menu height: 9 items × 42px = 378px + menu padding/border = ~400px
                // Use conservative estimate of 420px to ensure full menu visibility
                var menuHeight = 420;

                // Use actual space calculations from JavaScript
                var actualSpaceBelow = position.ActualSpaceBelow;
                var actualSpaceAbove = position.ActualSpaceAbove;

                // Open towards the side with more space
                // If both sides have enough space, prefer below (default)
                if (actualSpaceBelow >= menuHeight)
                {
                    // Enough space below - open below
                    menuPositionAbove = false;
                }
                else if (actualSpaceAbove >= menuHeight)
                {
                    // Not enough below, but enough above - open above
                    menuPositionAbove = true;
                }
                else
                {
                    // Neither side has full space - open towards the larger side
                    menuPositionAbove = actualSpaceAbove > actualSpaceBelow;
                }
            }
        }
        catch
        {
            menuPositionAbove = false;
        }
    }

    private void CloseMoreMenu()
    {
        showMoreMenu = false;
    }

    private async Task SelectReaction(string emoji)
    {
        showReactionPickerCts?.Cancel();
        showReactionPicker = false;
        await OnReaction.InvokeAsync(emoji);
        await OnActionCompleted.InvokeAsync();
    }

    private async Task HandleReplyButtonClick()
    {
        CloseMoreMenu();
        await OnReply.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private async Task OnCopyClick()
    {
        CloseMoreMenu();
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", Content);
        }
        catch
        {
            // Ignore copy errors
        }
        await OnActionCompleted.InvokeAsync();
    }

    private async Task OnForwardClick()
    {
        CloseMoreMenu();
        await OnForward.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private async Task OnPinClick()
    {
        CloseMoreMenu();
        await OnPin.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private async Task HandleReplyClick()
    {
        if (ReplyToMessageId.HasValue)
        {
            await OnReplyClick.InvokeAsync(ReplyToMessageId.Value);
        }
        await OnActionCompleted.InvokeAsync();
    }

    private Task HandleAddToFavoritesClick()
    {
        // TODO: Implement Add to Favorites functionality
        CloseMoreMenu();
        return Task.CompletedTask;
    }

    private async Task HandleMarkAsLaterClick()
    {
        CloseMoreMenu();
        // Toggle: same messageId -> unmark, different/none -> mark
        await OnMarkAsLater.InvokeAsync(MessageId);
        await OnActionCompleted.InvokeAsync();
    }

    private async Task HandleSelectClick()
    {
        CloseMoreMenu();
        // Trigger selection toggle - this will enter select mode and select this message
        await OnSelectToggle.InvokeAsync(MessageId);
        await OnActionCompleted.InvokeAsync();
    }

    private async Task HandleBubbleClick()
    {
        // Only toggle selection if in select mode and message is not deleted
        if (IsSelectMode && !IsDeleted)
        {
            await OnSelectToggle.InvokeAsync(MessageId);
        }
    }

    private bool IsMarkedAsLater => LastReadLaterMessageId.HasValue && LastReadLaterMessageId.Value == MessageId;

    // Helper to get reactions list (works for both MessageReactionDto and ChannelMessageReactionDto)
    private List<dynamic>? GetReactionsList()
    {
        if (Reactions == null) return null;

        if (Reactions is List<MessageReactionDto> directReactions)
            return directReactions.Cast<dynamic>().ToList();

        if (Reactions is List<ChannelMessageReactionDto> channelReactions)
            return channelReactions.Cast<dynamic>().ToList();

        return null;
    }

    private string GetReactionTooltip(dynamic reaction)
    {
        string emoji = reaction.Emoji;
        int count = reaction.Count;

        if (count == 1)
        {
            return $"{emoji} 1 person";
        }
        return $"{emoji} {count} people";
    }

    private Task ShowReactionUsers(int index)
    {
        // Cancel any pending hide operation
        hideReactionPanelCts?.Cancel();
        hideReactionPanelCts = null;

        hoveredReactionIndex = index;
        return Task.CompletedTask;
    }

    private async Task ScheduleHideReactionUsers()
    {
        // Cancel any existing hide operation
        hideReactionPanelCts?.Cancel();

        // Create new cancellation token
        hideReactionPanelCts = new CancellationTokenSource();
        var token = hideReactionPanelCts.Token;

        try
        {
            // Wait 300ms before hiding
            await Task.Delay(300, token);

            // If not cancelled, hide the panel
            if (!token.IsCancellationRequested)
            {
                hoveredReactionIndex = null;
                StateHasChanged();
            }
        }
        catch (TaskCanceledException)
        {
            // Expected when hovering back
        }
    }

    private Task CancelHideReactionUsers()
    {
        // Cancel the scheduled hide operation
        hideReactionPanelCts?.Cancel();
        hideReactionPanelCts = null;
        return Task.CompletedTask;
    }

    private record MenuPositionInfo
    {
        public double Top { get; set; }
        public double Bottom { get; set; }
        public double ViewportHeight { get; set; }
        public double ChatHeaderHeight { get; set; }
        public double MessageInputHeight { get; set; }
        public double MessageInputTop { get; set; }
        public double ChatHeaderBottom { get; set; }
        public double ActualSpaceBelow { get; set; }
        public double ActualSpaceAbove { get; set; }
    }
}