@inject IJSRuntime JS

<div id="message-@MessageId" class="message-wrapper @(IsOwn ? "own" : "other") @(IsDeleted ? "deleted" : "") @(!IsDirectMessage && !IsOwn ? "group-message" : "")" @ref="messageWrapperRef">
    @if (!IsOwn && !IsDirectMessage)
    {
        <!-- Always show avatar space for group messages to maintain alignment -->
        <div class="message-avatar @(!ShowAvatar ? "avatar-spacer" : "")">
            @if (ShowAvatar)
            {
                @if (!string.IsNullOrEmpty(AvatarUrl))
                {
                    <img src="@AvatarUrl" alt="@SenderName" />
                }
                else
                {
                    <div class="avatar-placeholder">@GetInitials(SenderName)</div>
                }
            }
        </div>
    }

    <div class="message-content-wrapper">
        @if (!IsOwn && ShowSenderName)
        {
            <div class="message-sender">@SenderName</div>
        }
        <div class="message-bubble @(IsOwn ? "own-bubble" : "other-bubble")">
            @if (IsDeleted)
            {
                <div class="deleted-message">
                    <MudIcon Icon="@Icons.Material.Filled.Block" Size="Size.Small" />
                    <span>This message was deleted</span>
                </div>
            }
            else
            {
                <div class="message-content-block">
                    @* Show forwarded indicator *@
                    @if (IsForwarded)
                    {
                        <div class="forwarded-label">
                            <MudIcon Icon="@Icons.Material.Filled.Forward" Size="Size.Small" />
                            <span>Forwarded</span>
                        </div>
                    }

                    @* Show replied message preview if this is a reply *@
                    @if (!string.IsNullOrEmpty(ReplyToContent))
                    {
                        <div class="reply-preview clickable" @onclick="HandleReplyClick">
                            <div class="reply-bar"></div>
                            <div class="reply-content">
                                <div class="reply-sender">@ReplyToSenderName</div>
                                <div class="reply-text">@TruncateText(ReplyToContent, 50)</div>
                            </div>
                        </div>
                    }

                    <!-- WhatsApp-style: Text and time inline -->
                    <div class="message-text-container">
                        <span class="message-text">@Content</span>

                        <!-- Time and status inline at the end -->
                        <span class="message-meta-inline">
                            @if (IsEdited)
                            {
                                <span class="edited-label">Edited</span>
                            }
                            @if (IsPinned)
                            {
                                <MudIcon Icon="@Icons.Material.Filled.PushPin" Size="Size.Small" Class="pinned-icon-inline" />
                            }
                            <span class="message-time-inline">@FormatTime(CreatedAt)</span>
                            @if (IsOwn && !IsDeleted && IsDirectMessage)
                            {
                                <span class="read-status-inline">
                                    @if (IsRead)
                                    {
                                        <MudIcon Icon="@Icons.Material.Filled.DoneAll" Size="Size.Small" Class="read-icon" />
                                    }
                                    else
                                    {
                                        <MudIcon Icon="@Icons.Material.Filled.Done" Size="Size.Small" />
                                    }
                                </span>
                            }
                        </span>
                    </div>

                    <!-- Chevron button - positioned absolutely, doesn't affect layout -->
                    @if (!IsDeleted)
                    {
                        <button class="chevron-more-btn @(showMoreMenu ? "visible" : "")"
                                title="More"
                                @onclick="ToggleMoreMenu"
                                @onclick:stopPropagation="true">
                            <MudIcon Icon="@Icons.Material.Filled.KeyboardArrowDown" Size="Size.Small" />
                        </button>
                    }
                </div>
            }
        </div>
        @if (ReactionCount > 0 && !IsDeleted)
        {
            <div class="message-reactions">
                <span class="reaction-badge">
                    <MudIcon Icon="@Icons.Material.Filled.ThumbUp" Size="Size.Small" /> @ReactionCount
                </span>
            </div>
        }
    </div>

    @if (IsOwn && ShowAvatar)
    {
        <div class="message-avatar own-avatar">
            @if (!string.IsNullOrEmpty(AvatarUrl))
            {
                <img src="@AvatarUrl" alt="@SenderName" />
            }
            else
            {
                <div class="avatar-placeholder">@GetInitials(SenderName)</div>
            }
        </div>
    }

    <!-- Message Actions (visible on hover, hidden when popup is open) -->
    @if (!IsDeleted && !showReactionPicker && !showMoreMenu)
    {
        <div class="message-actions">
            <button class="action-btn" title="React" @onclick="ToggleReactionPicker"
                    @onclick:stopPropagation="true">
                <MudIcon Icon="@Icons.Material.Filled.EmojiEmotions" Size="Size.Small" />
            </button>
        </div>
    }

    <!-- Reaction Picker (positioned near message) -->
    @if (showReactionPicker)
    {
        <div class="popup-overlay" @onclick="CloseReactionPicker"></div>
        <div class="reaction-picker-popup" @onclick:stopPropagation="true">
            @foreach (var emoji in CommonReactions)
            {
                <button class="reaction-btn" @onclick="() => SelectReaction(emoji)">@emoji</button>
            }
        </div>
    }

    <!-- More Menu (positioned relative to chevron button inside bubble) -->
    @if (showMoreMenu)
    {
        <div class="popup-overlay" @onclick="CloseMoreMenu"></div>
        <div class="chevron-more-menu @(menuPositionAbove ? "position-above" : "position-below")" @onclick:stopPropagation="true">
            <button class="menu-item" @onclick="HandleReplyButtonClick">
                <MudIcon Icon="@Icons.Material.Filled.Reply" Size="Size.Small" />
                <span>Reply</span>
            </button>
            <button class="menu-item" @onclick="OnCopyClick">
                <MudIcon Icon="@Icons.Material.Filled.ContentCopy" Size="Size.Small" />
                <span>Copy</span>
            </button>
            <button class="menu-item" @onclick="OnForwardClick">
                <MudIcon Icon="@Icons.Material.Filled.Forward" Size="Size.Small" />
                <span>Forward</span>
            </button>
            @if (!IsDirectMessage)
            {
                <button class="menu-item" @onclick="OnPinClick">
                    <MudIcon Icon="@Icons.Material.Filled.PushPin" Size="Size.Small" />
                    <span>@(IsPinned ? "Unpin" : "Pin")</span>
                </button>
            }
            @if (IsOwn && !IsDeleted)
            {
                <button class="menu-item" @onclick="OnEditClick">
                    <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" />
                    <span>Edit</span>
                </button>
                <button class="menu-item delete-item" @onclick="OnDeleteClick">
                    <MudIcon Icon="@Icons.Material.Filled.Delete" Size="Size.Small" />
                    <span>Delete</span>
                </button>
            }
        </div>
    }
</div>

@code {
    [Parameter] public Guid MessageId { get; set; }
    [Parameter] public string Content { get; set; } = "";
    [Parameter] public string SenderName { get; set; } = "";
    [Parameter] public string? AvatarUrl { get; set; }
    [Parameter] public DateTime CreatedAt { get; set; }
    [Parameter] public bool IsOwn { get; set; }
    [Parameter] public bool IsEdited { get; set; }
    [Parameter] public bool IsDeleted { get; set; }
    [Parameter] public bool IsRead { get; set; }
    [Parameter] public bool IsPinned { get; set; }
    [Parameter] public int ReactionCount { get; set; }
    [Parameter] public bool ShowAvatar { get; set; }
    [Parameter] public bool ShowSenderName { get; set; }
    [Parameter] public bool IsDirectMessage { get; set; }

    // Reply-related parameters
    [Parameter] public Guid? ReplyToMessageId { get; set; }
    [Parameter] public string? ReplyToContent { get; set; }
    [Parameter] public string? ReplyToSenderName { get; set; }
    [Parameter] public bool IsForwarded { get; set; }
    [Parameter] public EventCallback OnEdit { get; set; }
    [Parameter] public EventCallback OnDelete { get; set; }
    [Parameter] public EventCallback<string> OnReaction { get; set; }
    [Parameter] public EventCallback OnReply { get; set; }
    [Parameter] public EventCallback OnPin { get; set; }
    [Parameter] public EventCallback OnForward { get; set; }
    [Parameter] public EventCallback<Guid> OnReplyClick { get; set; }
    [Parameter] public EventCallback OnActionCompleted{ get; set; }
    [Parameter] public EventCallback ScrollToBottom{ get; set; }

    private ElementReference messageWrapperRef;
    private bool showReactionPicker = false;
    private bool showMoreMenu = false;
    private bool menuPositionAbove = false;
    private readonly string[] CommonReactions = { "👍", "❤️", "😂", "😮", "😢", "🎉" };

    private string GetInitials(string name)
    {
        if (string.IsNullOrEmpty(name)) return "?";
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length >= 2
            ? $"{parts[0][0]}{parts[1][0]}".ToUpper()
            : name[0].ToString().ToUpper();
    }

    private string FormatTime(DateTime dateTime)
    {
        return dateTime.ToLocalTime().ToString("HH:mm");
    }

    private string TruncateText(string? text, int maxLength)
    {
        if (string.IsNullOrEmpty(text)) return "";
        if (text.Length <= maxLength) return text;
        return text.Substring(0, maxLength) + "...";
    }

    private async Task OnEditClick()
    {
        CloseMoreMenu();
        await OnEdit.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
        await ScrollToBottom.InvokeAsync();
    }

    private async Task OnDeleteClick()
    {
        CloseMoreMenu();
        await OnDelete.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private void ToggleReactionPicker()
    {
        showReactionPicker = !showReactionPicker;
        showMoreMenu = false;
    }

    private void CloseReactionPicker()
    {
        showReactionPicker = false;
    }

    private async Task ToggleMoreMenu()
    {
        if (!showMoreMenu)
        {
            // Check if menu should appear above or below
            await CheckMenuPosition();
        }
        showMoreMenu = !showMoreMenu;
        showReactionPicker = false;
    }

    private async Task CheckMenuPosition()
    {
        try
        {
            var position = await JS.InvokeAsync<MenuPositionInfo>("chatAppUtils.getElementPosition", messageWrapperRef);
            if (position != null)
            {
                // Menu height is approximately 200px (6 items * ~33px each)
                var menuHeight = 200;
                var spaceBelow = position.ViewportHeight - position.Bottom;
                menuPositionAbove = spaceBelow < menuHeight && position.Top > menuHeight;
            }
        }
        catch
        {
            menuPositionAbove = false;
        }
    }

    private void CloseMoreMenu()
    {
        showMoreMenu = false;
    }

    private async Task SelectReaction(string emoji)
    {
        showReactionPicker = false;
        await OnReaction.InvokeAsync(emoji);
    }

    private async Task HandleReplyButtonClick()
    {
        CloseMoreMenu();
        await OnReply.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private async Task OnCopyClick()
    {
        CloseMoreMenu();
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", Content);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Copy failed: {ex.Message}");
        }
        await OnActionCompleted.InvokeAsync();
    }

    private async Task OnForwardClick()
    {
        CloseMoreMenu();
        await OnForward.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private async Task OnPinClick()
    {
        CloseMoreMenu();
        await OnPin.InvokeAsync();
        await OnActionCompleted.InvokeAsync();
    }

    private async Task HandleReplyClick()
    {
        if (ReplyToMessageId.HasValue)
        {
            await OnReplyClick.InvokeAsync(ReplyToMessageId.Value);
        }
        await OnActionCompleted.InvokeAsync();
    }

    private record MenuPositionInfo
    {
        public double Top { get; set; }
        public double Bottom { get; set; }
        public double ViewportHeight { get; set; }
    }
}