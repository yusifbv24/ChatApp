@implements IAsyncDisposable
@inject IJSRuntime JS
@using ChatApp.Blazor.Client.Models.Auth

<div class="chat-area">
    @if (IsEmpty)
    {
        <!-- Empty State -->
        <div class="chat-empty-state">
            <div class="empty-illustration">
                <MudIcon Icon="@Icons.Material.Filled.Forum" Class="empty-main-icon"/>
            </div>
            <h2>Select a conversation</h2>
            <p>Choose a conversation from the list or start a new one</p>
        </div>
    }
    else
    {
        <!-- Chat Header -->
        <div class="chat-header">
            <div class="chat-header-info">
                @if (IsDirectMessage)
                {
                    <div class="header-avatar">
                        @if (!string.IsNullOrEmpty(RecipientAvatarUrl))
                        {
                            <img src="@RecipientAvatarUrl" alt="@RecipientName" />
                        }
                        else
                        {
                            <div class="avatar-placeholder">@GetInitials(RecipientName)</div>
                        }
                        <span class="online-indicator @(IsRecipientOnline ? "online" : "offline")"></span>
                    </div>
                    <div class="header-details">
                        <h3 class="header-name">@RecipientName</h3>
                        @if (TypingUsers?.Any() ?? false)
                        {
                            <span class="header-status typing">typing...</span>
                        }
                        else
                        {
                            <span class="header-status">@(IsRecipientOnline ? "Online" : "Offline")</span>
                        }
                    </div>
                }
                else
                {
                    <div class="header-channel-icon">
                        <MudIcon Icon="@(ChannelType==ChannelType.Private ? Icons.Material.Filled.Lock : Icons.Material.Filled.Tag)" />
                    </div>
                    <div class="header-details">
                        <h3 class="header-name">@ChannelName</h3>
                        @if (TypingUsers?.Any() ?? false)
                        {
                            <span class="header-status typing">
                                @if (TypingUsers.Count == 1)
                                {
                                    <text>@TypingUsers[0] is typing...</text>
                                }
                                else if (TypingUsers.Count == 2)
                                {
                                    <text>@TypingUsers[0] and @TypingUsers[1] are typing...</text>
                                }
                                else
                                {
                                    <text>@TypingUsers.Count people are typing...</text>
                                }
                            </span>
                        }
                        else
                        {
                            <span class="header-status">@MemberCount members</span>
                        }
                    </div>
                }
            </div>
            <div class="chat-header-actions">
                @if (!IsDirectMessage && IsChannelAdmin)
                {
                    <button class="header-action-btn" title="Add member" @onclick="ToggleAddMemberPanel">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" />
                    </button>
                }
                <button class="header-action-btn" title="Search" @onclick="() => OnToggleSearchPanel.InvokeAsync()">
                    <MudIcon Icon="@Icons.Material.Filled.Search" />
                </button>
                <button class="header-action-btn" title="Info" @onclick="ToggleInfoPanel">
                    <MudIcon Icon="@Icons.Material.Filled.Info" />
                </button>
            </div>
        </div>

        <!-- Pinned Messages Header -->
        @if ((IsDirectMessage && PinnedDirectMessageCount > 0) || (!IsDirectMessage && PinnedCount > 0))
        {
            <div class="pinned-messages-header-wrapper">
                <div class="pinned-messages-header" @onclick="HandlePinnedHeaderClick">
                    <div class="pinned-header-content">
                        <div class="pinned-header-left">
                            <div class="pinned-message-info">
                                @if (showPinnedDropdown)
                                {
                                    <span class="pinned-title-expanded">Pinned messages : <span class="pinned-title-count">@(IsDirectMessage ? PinnedDirectMessageCount : PinnedCount)</span></span>
                                }
                                else
                                {
                                    <span class="pinned-title">Pinned messages</span>
                                    var currentPinned = IsDirectMessage ? GetCurrentPinnedDirectMessage() : null;
                                    var currentChannelPinned = !IsDirectMessage ? GetCurrentPinnedChannelMessage() : null;
                                    var senderName = currentPinned?.SenderDisplayName ?? currentChannelPinned?.SenderDisplayName;
                                    var messageContent = currentPinned?.Content ?? currentChannelPinned?.Content;

                                    if (!string.IsNullOrEmpty(senderName))
                                    {
                                        <span class="pinned-preview">
                                            <span class="pinned-sender-name">@senderName</span>
                                            <span class="pinned-separator">:</span>
                                            <span class="pinned-message-text">@TruncateText(messageContent, 50)</span>
                                        </span>
                                    }
                                }
                            </div>
                        </div>
                        <div class="pinned-header-right">
                            @if (showPinnedDropdown)
                            {
                                <button class="pinned-close-btn" @onclick="ClosePinnedDropdown" @onclick:stopPropagation="true">
                                    <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
                                </button>
                            }
                            else
                            {
                                <button class="pinned-toggle-btn-vertical" @onclick="TogglePinnedDropdown" @onclick:stopPropagation="true">
                                    <MudIcon Icon="@Icons.Material.Outlined.PushPin" Size="Size.Small" Class="pinned-icon-dark" />
                                    <span class="pinned-count-dark">@(currentPinnedIndex + 1)/@(IsDirectMessage ? PinnedDirectMessageCount : PinnedCount)</span>
                                </button>
                            }
                        </div>
                    </div>
                </div>

                @if (showPinnedDropdown)
                {
                    <div class="pinned-dropdown-panel">
                        <div class="pinned-dropdown-list">
                            @if (IsDirectMessage)
                            {
                                @foreach (var message in PinnedDirectMessages)
                                {
                                    <div class="pinned-dropdown-item" @onclick="() => NavigateToPinnedMessage(message.Id)">
                                        <div class="pinned-item-avatar">
                                            @if (!string.IsNullOrEmpty(message.SenderAvatarUrl))
                                            {
                                                <img src="@message.SenderAvatarUrl" alt="@message.SenderDisplayName" />
                                            }
                                            else
                                            {
                                                <div class="avatar-placeholder">@GetInitials(message.SenderDisplayName)</div>
                                            }
                                        </div>
                                        <div class="pinned-item-content">
                                            <span class="pinned-item-sender">@message.SenderDisplayName</span>
                                            <span class="pinned-item-text">@TruncateText(message.Content, 60)</span>
                                        </div>
                                        <button class="unpin-btn" @onclick="() => HandleUnpinMessage(message.Id)" @onclick:stopPropagation="true" title="Unpin">
                                            <MudIcon Icon="@Icons.Material.Outlined.PushPin" Size="Size.Small" />
                                        </button>
                                    </div>
                                }
                            }
                            else
                            {
                                @foreach (var message in PinnedChannelMessages)
                                {
                                    <div class="pinned-dropdown-item" @onclick="() => NavigateToPinnedMessage(message.Id)">
                                        <div class="pinned-item-avatar">
                                            @if (!string.IsNullOrEmpty(message.SenderAvatarUrl))
                                            {
                                                <img src="@message.SenderAvatarUrl" alt="@message.SenderDisplayName" />
                                            }
                                            else
                                            {
                                                <div class="avatar-placeholder">@GetInitials(message.SenderDisplayName)</div>
                                            }
                                        </div>
                                        <div class="pinned-item-content">
                                            <span class="pinned-item-sender">@message.SenderDisplayName</span>
                                            <span class="pinned-item-text">@TruncateText(message.Content, 60)</span>
                                        </div>
                                        <button class="unpin-btn" @onclick="() => HandleUnpinChannelMessage(message.Id)" @onclick:stopPropagation="true" title="Unpin">
                                            <MudIcon Icon="@Icons.Material.Outlined.PushPin" Size="Size.Small" />
                                        </button>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                }
            </div>
        }

        <!-- Messages Area -->
        <div class="messages-container" @ref="messagesContainerRef" @onscroll="HandleScroll">
            @if (IsLoading)
            {
                <div class="messages-loading">
                    <div class="loading-spinner"></div>
                    <span>Loading messages...</span>
                </div>
            }
            else if (HasMoreMessages && !IsLoadingMore)
            {
                <div class="load-more-trigger" @ref="loadMoreTriggerRef">
                    <!-- Invisible trigger element for infinite scroll -->
                </div>
            }
            else if (IsLoadingMore)
            {
                <div class="load-more-container">
                    <div class="loading-spinner small"></div>
                    <span>Loading...</span>
                </div>
            }
            @if (DirectMessages.Any())
            {
                @foreach(var group in GroupedDirectMessages)
                {
                    <div class="message-group">
                        <div class="date-divider">
                            <span>@FormatDateDivider(group.Key)</span>
                        </div>
                        <div class="messages-in-group">
                            @foreach(var message in group)
                            {
                                @* Read Later separator appears BEFORE the marked message *@
                                @* Only show if there's NO unread separator (unread has priority) *@
                                @if (LastReadLaterMessageId.HasValue && message.Id == LastReadLaterMessageId.Value && !UnreadSeparatorAfterMessageId.HasValue)
                                {
                                    <div class="unread-separator" id="read-later-separator">
                                        <span>Read Later</span>
                                    </div>
                                }

                                <MessageBubble @key="message.Id"
                                       MessageId="message.Id"
                                       Content="@message.Content"
                                       SenderName="@message.SenderDisplayName"
                                       AvatarUrl="@message.SenderAvatarUrl"
                                       CreatedAt="@message.CreatedAtUtc"
                                       IsOwn="@(message.SenderId==CurrentUserId)"
                                       IsEdited="@message.IsEdited"
                                       IsDeleted="@message.IsDeleted"
                                       IsRead="@message.IsRead"
                                       IsPinned="@message.IsPinned"
                                       IsFavorite="@FavoriteMessageIds.Contains(message.Id)"
                                       ReactionCount="@message.ReactionCount"
                                       Reactions="@message.Reactions"
                                       CurrentUserId="@CurrentUserId"
                                       IsDirectMessage="true"
                                       ShowAvatar="false"
                                       ShowSenderName="false"
                                       ReplyToMessageId="@message.ReplyToMessageId"
                                       ReplyToContent="@message.ReplyToContent"
                                       ReplyToSenderName="@message.ReplyToSenderName"
                                       IsForwarded="@message.IsForwarded"
                                       LastReadLaterMessageId="@LastReadLaterMessageId"
                                       IsSelectMode="@IsSelectMode"
                                       IsSelected="@SelectedMessageIds.Contains(message.Id)"
                                       OnSelectToggle="OnSelectToggle"
                                       OnEdit="()=>StartEditMessage(message.Id,message.Content)"
                                       OnDelete="()=>DeleteMessage(message.Id)"
                                       OnReaction="(emoji)=>AddReaction(message.Id,emoji)"
                                       OnReply="()=>OnReply.InvokeAsync(message.Id)"
                                       OnPin="()=>PinDirectMessage(message.Id,message.IsPinned)"
                                       OnForward="()=>OnForward.InvokeAsync(message.Id)"
                                       OnToggleFavorite="()=>OnToggleFavorite.InvokeAsync(message.Id)"
                                       OnMarkAsLater="OnMarkAsLater"
                                       OnReplyClick="HandleReplyClick"
                                       OnActionCompleted="RefocusInput"
                                       ScrollToBottom="ScrollToBottomAsync" />

                                @if (UnreadSeparatorAfterMessageId.HasValue && message.Id == UnreadSeparatorAfterMessageId.Value)
                                {
                                    <div class="unread-separator" id="unread-separator">
                                        <span>New messages</span>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                }
            }
            else if (ChannelMessages.Any())
            {
                @foreach(var group in GroupedChannelMessages)
                {
                    <div class="message-group">
                        <div class="date-divider">
                            <span>@FormatDateDivider(group.Key)</span>
                        </div>
                        <div class="messages-in-group">
                            @foreach (var message in group)
                            {
                                @* Read Later separator appears BEFORE the marked message *@
                                @* Only show if there's NO unread separator (unread has priority) *@
                                @if (LastReadLaterMessageId.HasValue && message.Id == LastReadLaterMessageId.Value && !UnreadSeparatorAfterMessageId.HasValue)
                                {
                                    <div class="unread-separator" id="read-later-separator">
                                        <span>Read Later</span>
                                    </div>
                                }

                                <MessageBubble @key="message.Id"
                                       MessageId="message.Id"
                                       Content="@message.Content"
                                       SenderName="@message.SenderDisplayName"
                                       AvatarUrl="@message.SenderAvatarUrl"
                                       CreatedAt="@message.CreatedAtUtc"
                                       IsOwn="@(message.SenderId == CurrentUserId)"
                                       IsEdited="@message.IsEdited"
                                       IsDeleted="@message.IsDeleted"
                                       IsPinned="@message.IsPinned"
                                       IsFavorite="@FavoriteMessageIds.Contains(message.Id)"
                                       ReactionCount="@message.ReactionCount"
                                       Reactions="@message.Reactions"
                                       CurrentUserId="@CurrentUserId"
                                       ReadByCount="@message.ReadByCount"
                                       TotalMemberCount="@message.TotalMemberCount"
                                       IsDirectMessage="false"
                                       ShowAvatar="@ShouldShowChannelAvatar(message, group)"
                                       ShowSenderName="@ShouldShowSenderName(message, group)"
                                       ReplyToMessageId="@message.ReplyToMessageId"
                                       ReplyToContent="@message.ReplyToContent"
                                       ReplyToSenderName="@message.ReplyToSenderName"
                                       IsForwarded="@message.IsForwarded"
                                       LastReadLaterMessageId="@LastReadLaterMessageId"
                                       IsSelectMode="@IsSelectMode"
                                       IsSelected="@SelectedMessageIds.Contains(message.Id)"
                                       OnSelectToggle="OnSelectToggle"
                                       OnEdit="() => StartEditMessage(message.Id, message.Content)"
                                       OnDelete="() => DeleteMessage(message.Id)"
                                       OnReaction="(emoji) => AddReaction(message.Id, emoji)"
                                       OnReply="()=>OnReply.InvokeAsync(message.Id)"
                                       OnPin="()=>PinChannelMessage(message.Id, message.IsPinned)"
                                       OnForward="()=>OnForward.InvokeAsync(message.Id)"
                                       OnToggleFavorite="()=>OnToggleFavorite.InvokeAsync(message.Id)"
                                       OnMarkAsLater="OnMarkAsLater"
                                       OnReplyClick="HandleReplyClick"
                                       OnActionCompleted="RefocusInput"
                                       ScrollToBottom="ScrollToBottomAsync" />

                                @* Unread separator appears AFTER the last read message (existing behavior) *@
                                @if (UnreadSeparatorAfterMessageId.HasValue && message.Id == UnreadSeparatorAfterMessageId.Value)
                                {
                                    <div class="unread-separator" id="unread-separator">
                                        <span>New messages</span>
                                    </div>
                                }
                            }
                        </div>
                    </div>
                }
            }
            else if (!IsLoading)
            {
                <div class="no-messages">
                    <MudIcon Icon="@Icons.Material.Filled.ChatBubbleOutline" Class="no-messages-icon">
                        <p>No messages yet</p>
                        <span>Send a message to start the conversation</span>
                    </MudIcon>
                </div>
            }
            <div @ref="scrollAnchorRef"></div>
        </div>

        <!-- Scroll to Bottom Float Button -->
        @if (showScrollToBottom)
        {
            <button class="scroll-to-bottom-btn" @onclick="ScrollToBottomAndFocusAsync" type="button">
                <MudIcon Icon="@Icons.Material.Filled.KeyboardArrowDown" Size="Size.Medium" />
                @if (newMessagesCount > 0)
                {
                    <span class="new-messages-badge">@(newMessagesCount > 99 ? "99+" : newMessagesCount.ToString())</span>
                }
            </button>
        }

        <!-- Message Input or Selection Toolbar -->
        @if (IsSelectMode)
        {
            <SelectionToolbar SelectedCount="@SelectedMessageIds.Count"
                             CanDelete="@CanDeleteSelected"
                             OnCancel="OnCancelSelection"
                             OnDelete="OnDeleteSelected"
                             OnForward="OnForwardSelected" />
        }
        else
        {
            <MessageInput @ref="messageInputRef"
                          Placeholder="@GetInputPlaceholder()"
                          IsEditing="@isEditing"
                          EditingContent="@editingContent"
                          IsSending="@IsSending"
                          ConversationId="@ConversationId"
                          IsReplying="@IsReplying"
                          ReplyToSenderName="@ReplyToSenderName"
                          ReplyToContent="@ReplyToContent"
                          InitialDraft="@InitialDraft"
                          OnSend="SendMessage"
                          OnEdit="EditMessage"
                          OnCancelEdit="CancelEdit"
                          OnCancelReply="OnCancelReply"
                          OnTyping="HandleTyping"
                          OnAttach="HandleAttach"
                          OnDraftChanged="OnDraftChanged" />
        }
    }
</div>
<!-- Info Panel (slide out) -->
@if (showInfoPanel)
{
    <div class="info-panel-overlay" @onclick="CloseInfoPanel">
        <div class="info-panel" @onclick:stopPropagation="true">
            <div class="info-panel-header">
                <h3>@(IsDirectMessage? "Contact Info" : "Channel Info")</h3>
                <button class="close-panel-btn" @onclick="CloseInfoPanel">
                    <MudIcon Icon="@Icons.Material.Filled.Close" />
                </button>
            </div>
            <div class="info-panel-content">
                @if (IsDirectMessage)
                {
                    <div class="info-avatar-section">
                        @if (!string.IsNullOrEmpty(RecipientAvatarUrl))
                        {
                            <img src="@RecipientAvatarUrl" alt="@RecipientName" class="info-avatar" />
                        }
                        else
                        {
                            <div class="info-avatar-placeholder">@GetInitials(RecipientName)></div>
                        }
                        <h4>@RecipientName</h4>
                        <span class="info-status @(IsRecipientOnline ? "online" : "")">
                            @(IsRecipientOnline ? "Online" : "Offline")
                        </span>
                    </div>
                }
                else
                {
                    <div class="info-channel-section">
                        <div class="info-channel-icon">
                            <MudIcon Icon="@(ChannelType == ChannelType.Private ? Icons.Material.Filled.Lock : Icons.Material.Filled.Tag)" />
                        </div>
                        <h4>@ChannelName</h4>
                        <p class="info-description">@ChannelDescription</p>
                        <span class="info-members">@MemberCount members</span>
                    </div>
                }
            </div>
        </div>
    </div>
}

<!-- Add Member Dialog -->
@if (showAddMemberPanel)
{
    <div class="dialog-overlay" @onclick="CloseAddMemberPanel">
        <div class="dialog-content add-member-dialog" @onclick:stopPropagation="true">
            <div class="dialog-header">
                <h3>Add Member</h3>
                <button class="dialog-close-btn" @onclick="CloseAddMemberPanel">
                    <MudIcon Icon="@Icons.Material.Filled.Close" />
                </button>
            </div>
            <div class="dialog-body">
                <!-- Search Users -->
                <div class="member-search-section">
                    <div class="member-search-input">
                        <MudIcon Icon="@Icons.Material.Filled.Search" Size="Size.Small" />
                        <input type="text"
                               placeholder="Search users..."
                               value="@memberSearchQuery"
                               @oninput="OnMemberSearchInput" />
                    </div>

                    @if (isSearchingMembers)
                    {
                        <div class="member-search-loading">
                            <div class="loading-spinner small"></div>
                            <span>Searching...</span>
                        </div>
                    }
                    else if (memberSearchResults.Any())
                    {
                        <div class="member-search-results">
                            @foreach (var user in memberSearchResults)
                            {
                                <div class="member-search-item">
                                    <div class="member-avatar">
                                        @if (!string.IsNullOrEmpty(user.AvatarUrl))
                                        {
                                            <img src="@user.AvatarUrl" alt="@user.DisplayName" />
                                        }
                                        else
                                        {
                                            <div class="avatar-placeholder">@GetInitials(user.DisplayName)</div>
                                        }
                                    </div>
                                    <div class="member-info">
                                        <span class="member-name">@user.DisplayName</span>
                                        <span class="member-username">@@@user.Username</span>
                                    </div>
                                    <div class="member-actions">
                                        <select class="role-select" @bind="selectedRoleForUser[user.Id]">
                                            <option value="@ChannelMemberRole.Member">Member</option>
                                            <option value="@ChannelMemberRole.Admin">Admin</option>
                                        </select>
                                        <button class="add-member-btn" @onclick="() => AddMemberToChannel(user.Id)" disabled="@isAddingMember">
                                            @if (isAddingMember && addingUserId == user.Id)
                                            {
                                                <div class="loading-spinner small"></div>
                                            }
                                            else
                                            {
                                                <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" />
                                            }
                                        </button>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                    else if (!string.IsNullOrEmpty(memberSearchQuery) && memberSearchQuery.Length >= 2)
                    {
                        <div class="member-search-empty">
                            <span>No users found</span>
                        </div>
                    }
                </div>

                @if (!string.IsNullOrEmpty(addMemberError))
                {
                    <div class="add-member-error">
                        <MudIcon Icon="@Icons.Material.Filled.Error" Size="Size.Small" />
                        <span>@addMemberError</span>
                    </div>
                }

                @if (!string.IsNullOrEmpty(addMemberSuccess))
                {
                    <div class="add-member-success">
                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" />
                        <span>@addMemberSuccess</span>
                    </div>
                }
            </div>
        </div>
    </div>
}


@code {
    [Parameter] public bool IsEmpty { get; set; } = true;
    [Parameter] public bool IsDirectMessage { get; set; } = true;
    [Parameter] public Guid CurrentUserId { get; set; }
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public Guid? ChannelId { get; set; }

    // Direct Message Parameters
    [Parameter] public List<DirectMessageDto> DirectMessages { get; set; } = new();
    [Parameter] public string RecipientName { get; set; } = string.Empty;
    [Parameter] public string? RecipientAvatarUrl { get; set; }
    [Parameter] public bool IsRecipientOnline { get; set; }

    // Channel Parameters
    [Parameter] public List<ChannelMessageDto> ChannelMessages { get; set; } = new();
    [Parameter] public string ChannelName { get; set; } = string.Empty;
    [Parameter] public string? ChannelDescription { get; set; }
    [Parameter] public ChannelType ChannelType { get; set; }
    [Parameter] public int MemberCount { get; set; }
    [Parameter] public int PinnedCount { get; set; }
    [Parameter] public int PinnedDirectMessageCount { get; set; }

    // Pinned messages for cycling
    [Parameter] public List<ChannelMessageDto> PinnedChannelMessages { get; set; } = new();
    [Parameter] public List<DirectMessageDto> PinnedDirectMessages { get; set; } = new();
    [Parameter] public EventCallback<Guid> OnNavigateToPinnedMessage { get; set; }
    [Parameter] public bool IsChannelAdmin { get; set; }

    // Common Parameters
    [Parameter] public bool IsLoading { get; set; }
    [Parameter] public bool IsLoadingMore { get; set; }
    [Parameter] public bool HasMoreMessages { get; set; }
    [Parameter] public bool IsSending { get; set; }
    [Parameter] public List<string> TypingUsers { get; set; } = new();

    // Event Callbacks
    [Parameter] public EventCallback<string> OnSendMessage { get; set; }
    [Parameter] public EventCallback<(Guid messageId, string content)> OnEditMessage { get; set; }
    [Parameter] public EventCallback<Guid> OnDeleteMessage { get; set; }
    [Parameter] public EventCallback<(Guid messageId, string emoji)> OnAddReaction { get; set; }
    [Parameter] public EventCallback<bool> OnTyping { get; set; }
    [Parameter] public EventCallback OnLoadMore { get; set; }
    [Parameter] public EventCallback<Guid> OnPinDirectMessage { get; set; }
    [Parameter] public EventCallback<Guid> OnUnpinDirectMessage { get; set; }
    [Parameter] public EventCallback<Guid> OnPinChannelMessage { get; set; }
    [Parameter] public EventCallback<Guid> OnUnpinChannelMessage { get; set; }
    [Parameter] public EventCallback<Guid> OnReply { get; set; }
    [Parameter] public EventCallback<Guid> OnForward { get; set; }
    [Parameter] public EventCallback OnCancelReply { get; set; }
    [Parameter] public EventCallback<(Guid userId, ChannelMemberRole role)> OnAddMember { get; set; }
    [Parameter] public EventCallback<string> OnSearchUsers { get; set; }
    [Parameter] public List<UserDto> UserSearchResults { get; set; } = new();
    [Parameter] public bool IsSearchingUsers { get; set; }

    // Reply state parameters
    [Parameter] public bool IsReplying { get; set; }
    [Parameter] public Guid? ReplyToMessageId { get; set; }
    [Parameter] public string? ReplyToSenderName { get; set; }
    [Parameter] public string? ReplyToContent { get; set; }

    // Unread separator
    [Parameter] public Guid? UnreadSeparatorAfterMessageId { get; set; }

    // Draft support
    [Parameter] public string? InitialDraft { get; set; }
    [Parameter] public EventCallback<string> OnDraftChanged { get; set; }

    // Read Later support (both conversations and channels)
    [Parameter] public Guid? LastReadLaterMessageId { get; set; }
    [Parameter] public EventCallback<Guid> OnMarkAsLater { get; set; }

    // Selection mode support
    [Parameter] public bool IsSelectMode { get; set; }
    [Parameter] public HashSet<Guid> SelectedMessageIds { get; set; } = new();
    [Parameter] public EventCallback<Guid> OnSelectToggle { get; set; }
    [Parameter] public EventCallback OnCancelSelection { get; set; }
    [Parameter] public EventCallback OnDeleteSelected { get; set; }
    [Parameter] public EventCallback OnForwardSelected { get; set; }
    [Parameter] public bool CanDeleteSelected { get; set; }

    // Favorites support
    [Parameter] public HashSet<Guid> FavoriteMessageIds { get; set; } = new();
    [Parameter] public EventCallback<Guid> OnToggleFavorite { get; set; }

    // Search panel
    [Parameter] public EventCallback OnToggleSearchPanel { get; set; }


    private ElementReference messagesContainerRef;
    private ElementReference scrollAnchorRef;
    private ElementReference loadMoreTriggerRef;
    private MessageInput? messageInputRef;
    private bool showInfoPanel = false;
    private bool showAddMemberPanel = false;
    private bool showScrollToBottom = false;
    private int newMessagesCount = 0;
    private bool isEditing = false;
    private Guid editingMessageId;
    private string editingContent = string.Empty;
    private int _previousMessageCount;
    private bool _shouldScrollToBottom;
    private bool _isLoadingMore = false;
    private object? _savedScrollPosition = null;
    private DateTime _lastScrollCheck = DateTime.MinValue;
    private int _scrollTopOnLastCheck = 0;
    private bool _hasScrolledToSeparator = false;
    private Guid? _previousUnreadSeparatorId = null;
    private bool _hasScrolledToReadLaterSeparator = false;
    private Guid? _previousReadLaterMessageId = null;

    // Add member panel state
    private string memberSearchQuery = string.Empty;
    private List<UserDto> memberSearchResults = new();
    private bool isSearchingMembers = false;
    private bool isAddingMember = false;
    private Guid? addingUserId = null;
    private string? addMemberError = null;
    private string? addMemberSuccess = null;
    private Dictionary<Guid, ChannelMemberRole> selectedRoleForUser = new();
    private CancellationTokenSource? _memberSearchCts;
    private int _previousChannelMessagesHash = 0;

    // Pinned messages cycling state
    private int currentPinnedIndex = 0;
    private bool showPinnedDropdown = false;

    private Guid? _previousConversationId;
    private Guid? _previousChannelId;

    protected override void OnParametersSet()
    {
        // Reset pinned index and close dropdown when conversation/channel changes
        if (ConversationId != _previousConversationId || ChannelId != _previousChannelId)
        {
            currentPinnedIndex = 0;
            showPinnedDropdown = false;
            _previousConversationId = ConversationId;
            _previousChannelId = ChannelId;
        }

        // Reset scroll flag if separator position changed (new conversation selected)
        if (UnreadSeparatorAfterMessageId != _previousUnreadSeparatorId)
        {
            _hasScrolledToSeparator = false;
            _previousUnreadSeparatorId = UnreadSeparatorAfterMessageId;
        }

        // Reset scroll flag if read later message changed (new conversation/channel selected)
        if (LastReadLaterMessageId != _previousReadLaterMessageId)
        {
            _hasScrolledToReadLaterSeparator = false;
            _previousReadLaterMessageId = LastReadLaterMessageId;
        }

        // Check if new messages were added (but not from load more)
        var currentCount = DirectMessages.Count + ChannelMessages.Count;

        // If this is first time seeing messages (was 0, now > 0), scroll to bottom
        if (_previousMessageCount == 0 && currentCount > 0)
        {
            _shouldScrollToBottom = true;
        }
        // Otherwise, only scroll to bottom if:
        // 1. New messages were added (currentCount increased)
        // 2. NOT from load more operation (detected by _isLoadingMore flag)
        // 3. NOT editing (editing doesn't add new messages)
        // 4. The increase is small (1-5 messages = new incoming, not pagination)
        // NOTE: Replying is ALLOWED - when user sends reply, scroll to show it
        else
        {
            var messageIncrease = currentCount - _previousMessageCount;
            var isNewIncomingMessage = messageIncrease > 0 && messageIncrease <= 5;

            if (isNewIncomingMessage && !_isLoadingMore && !isEditing)
            {
                // If user is scrolled up (float button visible), don't auto-scroll
                // Instead, increment the new messages counter
                if (showScrollToBottom)
                {
                    newMessagesCount += messageIncrease;
                    StateHasChanged();
                }
                else
                {
                    // User is at bottom, auto-scroll to show new message
                    _shouldScrollToBottom = true;
                }
            }
        }

        _previousMessageCount = currentCount;

        // Check if ChannelMessages list reference changed
        var currentHash = ChannelMessages.GetHashCode();
        if (currentHash != _previousChannelMessagesHash)
        {
            _previousChannelMessagesHash = currentHash;

            // Force immediate re-render when parameters change
            // This ensures MessageBubble components receive updated parameters like ReadByCount
            InvokeAsync(StateHasChanged);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_isLoadingMore && _savedScrollPosition != null)
        {
            // Wait for DOM to fully render new messages
            await Task.Delay(100);

            // Restore scroll position after loading more messages
            await JS.InvokeVoidAsync("chatAppUtils.restoreScrollPosition", messagesContainerRef, _savedScrollPosition);
            _isLoadingMore = false;
            _savedScrollPosition = null;
        }
        else if (_shouldScrollToBottom)
        {
            _shouldScrollToBottom = false;
            // Small delay to allow pinned header to render before scrolling
            // Without this, scroll happens before pinned header is visible,
            // causing scroll position to be incorrect
            await Task.Delay(50);
            await ScrollToBottomAsync();
        }
        else if (UnreadSeparatorAfterMessageId.HasValue && !_hasScrolledToSeparator && (DirectMessages.Any() || ChannelMessages.Any()))
        {
            // Scroll to unread separator on first render (priority 1)
            _hasScrolledToSeparator = true;
            await Task.Delay(100);
            await ScrollToUnreadSeparatorAsync();
        }
        else if (LastReadLaterMessageId.HasValue && !_hasScrolledToReadLaterSeparator && (DirectMessages.Any() || ChannelMessages.Any()))
        {
            // Scroll to read later separator on first render if no unread separator (priority 2)
            _hasScrolledToReadLaterSeparator = true;
            await Task.Delay(100);
            await ScrollToReadLaterSeparatorAsync();
        }
        else if (firstRender && (DirectMessages.Any() || ChannelMessages.Any()))
        {
            await ScrollToBottomAsync();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("chatAppUtils.scrollToBottom", messagesContainerRef);
        }
        catch
        {
            // Ignore scroll errors (component may be disposed)
        }
    }

    private async Task ScrollToBottomAndFocusAsync()
    {
        // Hide the scroll button immediately and reset counter
        showScrollToBottom = false;
        newMessagesCount = 0;
        StateHasChanged();

        // Scroll to bottom
        await ScrollToBottomAsync();

        // Focus message input
        if (messageInputRef != null)
        {
            await messageInputRef.FocusAsync();
        }
    }

    private async Task ScrollToUnreadSeparatorAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("chatAppUtils.scrollToElement", "unread-separator");
        }
        catch
        {
            // Ignore scroll errors (component may be disposed or element not found)
        }
    }

    private async Task ScrollToReadLaterSeparatorAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("chatAppUtils.scrollToElement", "read-later-separator");
        }
        catch
        {
            // Ignore scroll errors (component may be disposed or element not found)
        }
    }


    private IEnumerable<IGrouping<DateTime, DirectMessageDto>> GroupedDirectMessages =>
        DirectMessages
            .OrderBy(m => m.CreatedAtUtc)
            .GroupBy(m => m.CreatedAtUtc.Date);

    private IEnumerable<IGrouping<DateTime, ChannelMessageDto>> GroupedChannelMessages =>
        ChannelMessages
            .OrderBy(m => m.CreatedAtUtc)
            .GroupBy(m => m.CreatedAtUtc.Date);

    private static string GetInitials(string name)
    {
        if (string.IsNullOrWhiteSpace(name)) return "?";
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length >= 2
            ? $"{parts[0][0]}{parts[1][0]}".ToUpper()
            : name[0].ToString().ToUpper();
    }

    private string FormatDateDivider(DateTime date)
    {
        var now = DateTime.Now;
        var today = now.Date;

        // Bu günün mesajı - "today" (balaca hərflərlə)
        if (date == today)
        {
            return "today";
        }

        // Bu ilin mesajı - "Tuesday, December 23" formatı
        if (date.Year == now.Year)
        {
            return date.ToString("dddd, MMMM d", System.Globalization.CultureInfo.InvariantCulture);
        }

        // Keçən ilin mesajı - "Tuesday, September 17, 2019" formatı
        return date.ToString("dddd, MMMM d, yyyy", System.Globalization.CultureInfo.InvariantCulture);
    }

    private string GetInputPlaceholder()
    {
        return IsDirectMessage
            ? $"Message {RecipientName}..."
            : $"Message #{ChannelName}...";
    }

    private bool ShouldShowAvatar(DirectMessageDto message, IEnumerable<DirectMessageDto> messages)
    {
        var list = messages.ToList();
        var index = list.IndexOf(message);
        if (index == 0) return true;
        return list[index - 1].SenderId != message.SenderId;
    }

    private bool ShouldShowChannelAvatar(ChannelMessageDto message, IEnumerable<ChannelMessageDto> messages)
    {
        var list = messages.ToList();
        var index = list.IndexOf(message);

        // Show avatar on the LAST message of consecutive messages from same sender
        // If this is the last message in the list, show avatar
        if (index == list.Count - 1) return true;

        // If next message is from a different sender, show avatar (this is the last in the group)
        return list[index + 1].SenderId != message.SenderId;
    }

    private bool ShouldShowSenderName(ChannelMessageDto message, IEnumerable<ChannelMessageDto> messages)
    {
        var list = messages.ToList();
        var index = list.IndexOf(message);

        // Never show sender name for own messages
        if (message.SenderId == CurrentUserId) return false;

        // Show sender name on the FIRST message of consecutive messages from same sender
        // If this is the first message in the list, show sender name
        if (index == 0) return true;

        // If previous message is from a different sender, show sender name (this is the first in the group)
        return list[index - 1].SenderId != message.SenderId;
    }

    private void ToggleInfoPanel()
    {
        showInfoPanel = !showInfoPanel;
    }

    private void CloseInfoPanel()
    {
        showInfoPanel = false;
    }

    private DirectMessageDto? GetCurrentPinnedDirectMessage()
    {
        if (PinnedDirectMessages == null || PinnedDirectMessages.Count == 0)
            return null;

        // Ensure index is within bounds
        var safeIndex = currentPinnedIndex % PinnedDirectMessages.Count;
        return PinnedDirectMessages[safeIndex];
    }

    private ChannelMessageDto? GetCurrentPinnedChannelMessage()
    {
        if (PinnedChannelMessages == null || PinnedChannelMessages.Count == 0)
            return null;

        // Ensure index is within bounds
        var safeIndex = currentPinnedIndex % PinnedChannelMessages.Count;
        return PinnedChannelMessages[safeIndex];
    }

    private string TruncateText(string? text, int maxLength)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;

        return text.Length > maxLength ? text.Substring(0, maxLength) + "..." : text;
    }

    private async Task HandlePinnedHeaderClick()
    {
        // When dropdown is closed, clicking header navigates to current pinned message
        if (!showPinnedDropdown)
        {
            Guid? messageIdToNavigate = null;

            if (IsDirectMessage)
            {
                var currentPinned = GetCurrentPinnedDirectMessage();
                if (currentPinned != null)
                {
                    messageIdToNavigate = currentPinned.Id;
                    // Move to next pinned message for next click
                    currentPinnedIndex = (currentPinnedIndex + 1) % PinnedDirectMessageCount;
                }
            }
            else
            {
                var currentPinned = GetCurrentPinnedChannelMessage();
                if (currentPinned != null)
                {
                    messageIdToNavigate = currentPinned.Id;
                    // Move to next pinned message for next click
                    currentPinnedIndex = (currentPinnedIndex + 1) % PinnedCount;
                }
            }

            if (messageIdToNavigate.HasValue)
            {
                await OnNavigateToPinnedMessage.InvokeAsync(messageIdToNavigate.Value);
                StateHasChanged();
            }
        }
    }

    private void TogglePinnedDropdown()
    {
        showPinnedDropdown = !showPinnedDropdown;
    }

    private void ClosePinnedDropdown()
    {
        showPinnedDropdown = false;
    }

    private async Task NavigateToPinnedMessage(Guid messageId)
    {
        await OnNavigateToPinnedMessage.InvokeAsync(messageId);
        showPinnedDropdown = false;
        StateHasChanged();
    }

    private async Task HandleUnpinMessage(Guid messageId)
    {
        await OnUnpinDirectMessage.InvokeAsync(messageId);
        // Dropdown will update automatically when PinnedDirectMessages changes
    }

    private async Task HandleUnpinChannelMessage(Guid messageId)
    {
        await OnUnpinChannelMessage.InvokeAsync(messageId);
        // Dropdown will update automatically when PinnedChannelMessages changes
    }

    private async Task LoadMoreMessages()
    {
        // Save scroll position before loading
        _savedScrollPosition = await JS.InvokeAsync<object>("chatAppUtils.saveScrollPosition", messagesContainerRef);
        _isLoadingMore = true;
        await OnLoadMore.InvokeAsync();
    }

    private async Task SendMessage(string content)
    {
        await OnSendMessage.InvokeAsync(content);
    }

    private void StartEditMessage(Guid messageId, string content)
    {
        isEditing = true;
        editingMessageId = messageId;
        editingContent = content;
        StateHasChanged();
    }

    private async Task EditMessage(string newContent)
    {
        // If content hasn't changed, just cancel - no API call needed
        if (newContent == editingContent)
        {
            CancelEdit();
            return;
        }

        await OnEditMessage.InvokeAsync((editingMessageId, newContent));
        CancelEdit();
    }

    private void CancelEdit()
    {
        isEditing = false;
        editingMessageId = Guid.Empty;
        editingContent = "";
    }

    private async Task DeleteMessage(Guid messageId)
    {
        await OnDeleteMessage.InvokeAsync(messageId);
    }

    private async Task AddReaction(Guid messageId, string emoji)
    {
        await OnAddReaction.InvokeAsync((messageId, emoji));
    }

    private async Task HandleTyping(bool isTyping)
    {
        await OnTyping.InvokeAsync(isTyping);
    }

    private void HandleAttach()
    {
        // File attachment feature not implemented yet
    }

    private async Task RefocusInput()
    {
        // Refocus the textarea after any message action (edit, reply, copy, forward, etc.)
        if (messageInputRef != null)
        {
            await messageInputRef.FocusAsync();
        }
    }

    private async Task PinChannelMessage(Guid messageId, bool isPinned)
    {
        if (isPinned)
        {
            await OnUnpinChannelMessage.InvokeAsync(messageId);
        }
        else
        {
            await OnPinChannelMessage.InvokeAsync(messageId);
        }
    }

    private async Task PinDirectMessage(Guid messageId, bool isPinned)
    {
        if (isPinned)
        {
            await OnUnpinDirectMessage.InvokeAsync(messageId);
        }
        else
        {
            await OnPinDirectMessage.InvokeAsync(messageId);
        }
    }

    private async Task HandleReplyClick(Guid repliedMessageId)
    {
        try
        {
            // Use querySelector to find the message by ID
            await JS.InvokeVoidAsync("chatAppUtils.scrollToMessageById", $"message-{repliedMessageId}");
        }
        catch
        {
            // Message not loaded yet or element not found
        }
    }

    private async Task HandleScroll()
    {
        // Don't handle scroll during loading or restore
        if (_isLoadingMore || IsLoadingMore)
        {
            return;
        }

        try
        {
            // Get current scroll position
            var scrollTop = await JS.InvokeAsync<int>("chatAppUtils.getScrollTop", messagesContainerRef);

            // Check if user is near bottom (within 300px) to show/hide scroll button
            var isNearBottom = await JS.InvokeAsync<bool>("chatAppUtils.isNearBottom", messagesContainerRef, 300);
            var shouldShow = !isNearBottom;

            if (showScrollToBottom != shouldShow)
            {
                showScrollToBottom = shouldShow;

                // Reset counter when user scrolls to bottom manually
                if (!shouldShow)
                {
                    newMessagesCount = 0;
                }

                StateHasChanged();
            }

            // Cancel any pending scroll to bottom when user manually scrolls
            if (_shouldScrollToBottom && scrollTop > 0)
            {
                _shouldScrollToBottom = false;
            }

            // Don't proceed if no more messages to load
            if (!HasMoreMessages)
            {
                return;
            }

            // Throttle: Only trigger if scroll position changed significantly and enough time passed
            var now = DateTime.UtcNow;
            var timeSinceLastCheck = (now - _lastScrollCheck).TotalMilliseconds;
            var scrollDifference = Math.Abs(scrollTop - _scrollTopOnLastCheck);

            // Only proceed if:
            // 1. At least 200ms passed since last check
            // 2. Scroll position changed by at least 50px (significant scroll)
            if (timeSinceLastCheck < 200 || scrollDifference < 50)
            {
                return;
            }

            _lastScrollCheck = now;
            _scrollTopOnLastCheck = scrollTop;

            // If scrolled to within 200px of the top, trigger load more
            if (scrollTop < 200)
            {
                await LoadMoreMessages();
            }
        }
        catch
        {
            // Ignore scroll errors
        }
    }

    private async Task HandleChatAreaClick()
    {
        // Refocus the textarea when clicking anywhere in the chat area
        await RefocusInput();
    }

    #region Add Member Panel

    private void ToggleAddMemberPanel()
    {
        showAddMemberPanel = !showAddMemberPanel;
        if (!showAddMemberPanel)
        {
            ResetAddMemberPanel();
        }
    }

    private void CloseAddMemberPanel()
    {
        showAddMemberPanel = false;
        ResetAddMemberPanel();
    }

    private void ResetAddMemberPanel()
    {
        memberSearchQuery = string.Empty;
        memberSearchResults.Clear();
        selectedRoleForUser.Clear();
        addMemberError = null;
        addMemberSuccess = null;
        _memberSearchCts?.Cancel();
    }

    private async Task OnMemberSearchInput(ChangeEventArgs e)
    {
        memberSearchQuery = e.Value?.ToString() ?? "";
        addMemberError = null;
        addMemberSuccess = null;

        // Cancel previous search
        _memberSearchCts?.Cancel();
        _memberSearchCts = new CancellationTokenSource();
        var token = _memberSearchCts.Token;

        // Clear results if query is too short
        if (string.IsNullOrWhiteSpace(memberSearchQuery) || memberSearchQuery.Length < 2)
        {
            memberSearchResults.Clear();
            isSearchingMembers = false;
            StateHasChanged();
            return;
        }

        // Debounce - wait 300ms before searching
        try
        {
            await Task.Delay(300, token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        await SearchMembers(token);
    }

    private async Task SearchMembers(CancellationToken token)
    {
        if (token.IsCancellationRequested) return;

        isSearchingMembers = true;
        StateHasChanged();

        try
        {
            await OnSearchUsers.InvokeAsync(memberSearchQuery);

            if (token.IsCancellationRequested) return;

            // Copy results from parent and initialize role selections
            memberSearchResults = UserSearchResults.ToList();
            foreach (var user in memberSearchResults)
            {
                if (!selectedRoleForUser.ContainsKey(user.Id))
                {
                    selectedRoleForUser[user.Id] = ChannelMemberRole.Member;
                }
            }
        }
        catch
        {
            memberSearchResults.Clear();
        }
        finally
        {
            if (!token.IsCancellationRequested)
            {
                isSearchingMembers = false;
                StateHasChanged();
            }
        }
    }

    private async Task AddMemberToChannel(Guid userId)
    {
        if (isAddingMember) return;

        isAddingMember = true;
        addingUserId = userId;
        addMemberError = null;
        addMemberSuccess = null;
        StateHasChanged();

        try
        {
            var role = selectedRoleForUser.GetValueOrDefault(userId, ChannelMemberRole.Member);
            await OnAddMember.InvokeAsync((userId, role));

            // Remove from search results after successful add
            var user = memberSearchResults.FirstOrDefault(u => u.Id == userId);
            if (user != null)
            {
                addMemberSuccess = $"{user.DisplayName} added successfully";
                memberSearchResults.Remove(user);
                selectedRoleForUser.Remove(userId);
            }
        }
        catch (Exception ex)
        {
            addMemberError = ex.Message;
        }
        finally
        {
            isAddingMember = false;
            addingUserId = null;
            StateHasChanged();

            // Auto-close panel after 1 second (so user sees success message)
            if (!string.IsNullOrEmpty(addMemberSuccess))
            {
                _ = Task.Delay(1000).ContinueWith(_ =>
                {
                    InvokeAsync(() =>
                    {
                        CloseAddMemberPanel();
                    });
                });
            }
        }
    }

    #endregion

    public async ValueTask DisposeAsync()
    {
        _memberSearchCts?.Cancel();
        _memberSearchCts?.Dispose();
        await Task.CompletedTask;
    }
}