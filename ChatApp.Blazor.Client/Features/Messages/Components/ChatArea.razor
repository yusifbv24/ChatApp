@implements IAsyncDisposable
@inject IJSRuntime JS
@using ChatApp.Blazor.Client.Models.Auth

<div class="chat-area">
    @if (IsEmpty)
    {
        <!-- Empty State -->
        <div class="chat-empty-state">
            <div class="empty-illustration">
                <MudIcon Icon="@Icons.Material.Filled.Forum" Class="empty-main-icon"/>
            </div>
            <h2>Select a conversation</h2>
            <p>Choose a conversation from the list or start a new one</p>
        </div>
    }
    else
    {
        <!-- Chat Header -->
        <div class="chat-header">
            <div class="chat-header-info">
                @if (IsDirectMessage)
                {
                    <div class="header-avatar">
                        @if (!string.IsNullOrEmpty(RecipientAvatarUrl))
                        {
                            <img src="@RecipientAvatarUrl" alt="@RecipientName" />
                        }
                        else
                        {
                            <div class="avatar-placeholder">@GetInitials(RecipientName)</div>
                        }
                        <span class="online-indicator @(IsRecipientOnline ? "online" : "offline")"></span>
                    </div>
                    <div class="header-details">
                        <h3 class="header-name">@RecipientName</h3>
                        @if (TypingUsers?.Any() ?? false)
                        {
                            <span class="header-status typing">typing...</span>
                        }
                        else
                        {
                            <span class="header-status">@(IsRecipientOnline ? "Online" : "Offline")</span>
                        }
                    </div>
                }
                else
                {
                    <div class="header-channel-icon">
                        <MudIcon Icon="@(ChannelType==ChannelType.Private ? Icons.Material.Filled.Lock : Icons.Material.Filled.Tag)" />
                    </div>
                    <div class="header-details">
                        <h3 class="header-name">@ChannelName</h3>
                        @if (TypingUsers?.Any() ?? false)
                        {
                            <span class="header-status typing">
                                @if (TypingUsers.Count == 1)
                                {
                                    <text>@TypingUsers[0] is typing...</text>
                                }
                                else if (TypingUsers.Count == 2)
                                {
                                    <text>@TypingUsers[0] and @TypingUsers[1] are typing...</text>
                                }
                                else
                                {
                                    <text>@TypingUsers.Count people are typing...</text>
                                }
                            </span>
                        }
                        else
                        {
                            <span class="header-status">@MemberCount members</span>
                        }
                    </div>
                }
            </div>
            <div class="chat-header-actions">
                @if (!IsDirectMessage && IsChannelAdmin)
                {
                    <button class="header-action-btn" title="Add member" @onclick="ToggleAddMemberPanel">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" />
                    </button>
                }
                <button class="header-action-btn" title="Search" @onclick="ToggleSearch">
                    <MudIcon Icon="@Icons.Material.Filled.Search" />
                </button>
                <button class="header-action-btn" title="Info" @onclick="ToggleInfoPanel">
                    <MudIcon Icon="@Icons.Material.Filled.Info" />
                </button>
            </div>
        </div>

        @if (showSearch)
        {
            <div class="chat-search-bar">
                <MudIcon Icon="@Icons.Material.Filled.Search" Size="Size.Small" />
                <input type="text"
                       placeholder="Search in conversation..."
                       @bind="SearchQuery"
                       @bind:event="oninput" />
                <button class="close-search-btn" @onclick="ToggleSearch">
                    <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small"/>
                </button>
            </div>
        }

        <!-- Messages Area -->
        <div class="messages-container" @ref="messagesContainerRef" @onscroll="HandleScroll">
            @if (IsLoading)
            {
                <div class="messages-loading">
                    <div class="loading-spinner"></div>
                    <span>Loading messages...</span>
                </div>
            }
            else if (HasMoreMessages && !IsLoadingMore)
            {
                <div class="load-more-trigger" @ref="loadMoreTriggerRef">
                    <!-- Invisible trigger element for infinite scroll -->
                </div>
            }
            else if (IsLoadingMore)
            {
                <div class="load-more-container">
                    <div class="loading-spinner small"></div>
                    <span>Loading...</span>
                </div>
            }
            @if (DirectMessages.Any())
            {
                @foreach(var group in GroupedDirectMessages)
                {
                    <div class="message-group">
                        <div class="date-divider">
                            <span>@FormatDateDivider(group.Key)</span>
                        </div>
                        <div class="messages-in-group">
                            @foreach(var message in group)
                            {
                                <MessageBubble @key="message.Id"
                                       MessageId="message.Id"
                                       Content="@message.Content"
                                       SenderName="@message.SenderDisplayName"
                                       AvatarUrl="@message.SenderAvatarUrl"
                                       CreatedAt="@message.CreatedAtUtc"
                                       IsOwn="@(message.SenderId==CurrentUserId)"
                                       IsEdited="@message.IsEdited"
                                       IsDeleted="@message.IsDeleted"
                                       IsRead="@message.IsRead"
                                       ReactionCount="@message.ReactionCount"
                                       Reactions="@message.Reactions"
                                       CurrentUserId="@CurrentUserId"
                                       IsDirectMessage="true"
                                       ShowAvatar="false"
                                       ShowSenderName="false"
                                       ReplyToMessageId="@message.ReplyToMessageId"
                                       ReplyToContent="@message.ReplyToContent"
                                       ReplyToSenderName="@message.ReplyToSenderName"
                                       IsForwarded="@message.IsForwarded"
                                       OnEdit="()=>StartEditMessage(message.Id,message.Content)"
                                       OnDelete="()=>DeleteMessage(message.Id)"
                                       OnReaction="(emoji)=>AddReaction(message.Id,emoji)"
                                       OnReply="()=>OnReply.InvokeAsync(message.Id)"
                                       OnPin="()=>{}"
                                       OnForward="()=>OnForward.InvokeAsync(message.Id)"
                                       OnReplyClick="HandleReplyClick"
                                       OnActionCompleted="RefocusInput"
                                       ScrollToBottom="ScrollToBottomAsync" />
                            }
                        </div>
                    </div>
                }
            }
            else if (ChannelMessages.Any())
            {
                @foreach(var group in GroupedChannelMessages)
                {
                    <div class="message-group">
                        <div class="date-divider">
                            <span>@FormatDateDivider(group.Key)</span>
                        </div>
                        <div class="messages-in-group">
                            @foreach (var message in group)
                            {
                                <MessageBubble @key="message.Id"
                                       MessageId="message.Id"
                                       Content="@message.Content"
                                       SenderName="@message.SenderDisplayName"
                                       AvatarUrl="@message.SenderAvatarUrl"
                                       CreatedAt="@message.CreatedAtUtc"
                                       IsOwn="@(message.SenderId == CurrentUserId)"
                                       IsEdited="@message.IsEdited"
                                       IsDeleted="@message.IsDeleted"
                                       IsPinned="@message.IsPinned"
                                       ReactionCount="@message.ReactionCount"
                                       Reactions="@(message.Reactions.Select(r => new MessageReactionDto(r.Emoji, r.Count, r.UserIds)).ToList())"
                                       CurrentUserId="@CurrentUserId"
                                       ReadByCount="@message.ReadByCount"
                                       TotalMemberCount="@message.TotalMemberCount"
                                       IsDirectMessage="false"
                                       ShowAvatar="@ShouldShowChannelAvatar(message, group)"
                                       ShowSenderName="@ShouldShowSenderName(message, group)"
                                       ReplyToMessageId="@message.ReplyToMessageId"
                                       ReplyToContent="@message.ReplyToContent"
                                       ReplyToSenderName="@message.ReplyToSenderName"
                                       IsForwarded="@message.IsForwarded"
                                       OnEdit="() => StartEditMessage(message.Id, message.Content)"
                                       OnDelete="() => DeleteMessage(message.Id)"
                                       OnReaction="(emoji) => AddReaction(message.Id, emoji)"
                                       OnReply="()=>OnReply.InvokeAsync(message.Id)"
                                       OnPin="()=>PinMessage(message.Id)"
                                       OnForward="()=>OnForward.InvokeAsync(message.Id)"
                                       OnReplyClick="HandleReplyClick"
                                       OnActionCompleted="RefocusInput"
                                       ScrollToBottom="ScrollToBottomAsync" />
                            }
                        </div>
                    </div>
                }
            }
            else if (!IsLoading)
            {
                <div class="no-messages">
                    <MudIcon Icon="@Icons.Material.Filled.ChatBubbleOutline" Class="no-messages-icon">
                        <p>No messages yet</p>
                        <span>Send a message to start the conversation</span>
                    </MudIcon>
                </div>
            }
            <div @ref="scrollAnchorRef"></div>
        </div>

        <!-- Message Input -->
        <MessageInput @ref="messageInputRef"
                      Placeholder="@GetInputPlaceholder()"
                      IsEditing="@isEditing"
                      EditingContent="@editingContent"
                      IsSending="@IsSending"
                      ConversationId="@ConversationId"
                      IsReplying="@IsReplying"
                      ReplyToSenderName="@ReplyToSenderName"
                      ReplyToContent="@ReplyToContent"
                      OnSend="SendMessage"
                      OnEdit="EditMessage"
                      OnCancelEdit="CancelEdit"
                      OnCancelReply="OnCancelReply"
                      OnTyping="HandleTyping"
                      OnAttach="HandleAttach" />
    }
</div>
<!-- Info Panel (slide out) -->
@if (showInfoPanel)
{
    <div class="info-panel-overlay" @onclick="CloseInfoPanel">
        <div class="info-panel" @onclick:stopPropagation="true">
            <div class="info-panel-header">
                <h3>@(IsDirectMessage? "Contact Info" : "Channel Info")</h3>
                <button class="close-panel-btn" @onclick="CloseInfoPanel">
                    <MudIcon Icon="@Icons.Material.Filled.Close" />
                </button>
            </div>
            <div class="info-panel-content">
                @if (IsDirectMessage)
                {
                    <div class="info-avatar-section">
                        @if (!string.IsNullOrEmpty(RecipientAvatarUrl))
                        {
                            <img src="@RecipientAvatarUrl" alt="@RecipientName" class="info-avatar" />
                        }
                        else
                        {
                            <div class="info-avatar-placeholder">@GetInitials(RecipientName)></div>
                        }
                        <h4>@RecipientName</h4>
                        <span class="info-status @(IsRecipientOnline ? "online" : "")">
                            @(IsRecipientOnline ? "Online" : "Offline")
                        </span>
                    </div>
                }
                else
                {
                    <div class="info-channel-section">
                        <div class="info-channel-icon">
                            <MudIcon Icon="@(ChannelType == ChannelType.Private ? Icons.Material.Filled.Lock : Icons.Material.Filled.Tag)" />
                        </div>
                        <h4>@ChannelName</h4>
                        <p class="info-description">@ChannelDescription</p>
                        <span class="info-members">@MemberCount members</span>
                    </div>
                }
            </div>
        </div>
    </div>
}

<!-- Add Member Dialog -->
@if (showAddMemberPanel)
{
    <div class="dialog-overlay" @onclick="CloseAddMemberPanel">
        <div class="dialog-content add-member-dialog" @onclick:stopPropagation="true">
            <div class="dialog-header">
                <h3>Add Member</h3>
                <button class="dialog-close-btn" @onclick="CloseAddMemberPanel">
                    <MudIcon Icon="@Icons.Material.Filled.Close" />
                </button>
            </div>
            <div class="dialog-body">
                <!-- Search Users -->
                <div class="member-search-section">
                    <div class="member-search-input">
                        <MudIcon Icon="@Icons.Material.Filled.Search" Size="Size.Small" />
                        <input type="text"
                               placeholder="Search users..."
                               value="@memberSearchQuery"
                               @oninput="OnMemberSearchInput" />
                    </div>

                    @if (isSearchingMembers)
                    {
                        <div class="member-search-loading">
                            <div class="loading-spinner small"></div>
                            <span>Searching...</span>
                        </div>
                    }
                    else if (memberSearchResults.Any())
                    {
                        <div class="member-search-results">
                            @foreach (var user in memberSearchResults)
                            {
                                <div class="member-search-item">
                                    <div class="member-avatar">
                                        @if (!string.IsNullOrEmpty(user.AvatarUrl))
                                        {
                                            <img src="@user.AvatarUrl" alt="@user.DisplayName" />
                                        }
                                        else
                                        {
                                            <div class="avatar-placeholder">@GetInitials(user.DisplayName)</div>
                                        }
                                    </div>
                                    <div class="member-info">
                                        <span class="member-name">@user.DisplayName</span>
                                        <span class="member-username">@@@user.Username</span>
                                    </div>
                                    <div class="member-actions">
                                        <select class="role-select" @bind="selectedRoleForUser[user.Id]">
                                            <option value="@ChannelMemberRole.Member">Member</option>
                                            <option value="@ChannelMemberRole.Admin">Admin</option>
                                        </select>
                                        <button class="add-member-btn" @onclick="() => AddMemberToChannel(user.Id)" disabled="@isAddingMember">
                                            @if (isAddingMember && addingUserId == user.Id)
                                            {
                                                <div class="loading-spinner small"></div>
                                            }
                                            else
                                            {
                                                <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" />
                                            }
                                        </button>
                                    </div>
                                </div>
                            }
                        </div>
                    }
                    else if (!string.IsNullOrEmpty(memberSearchQuery) && memberSearchQuery.Length >= 2)
                    {
                        <div class="member-search-empty">
                            <span>No users found</span>
                        </div>
                    }
                </div>

                @if (!string.IsNullOrEmpty(addMemberError))
                {
                    <div class="add-member-error">
                        <MudIcon Icon="@Icons.Material.Filled.Error" Size="Size.Small" />
                        <span>@addMemberError</span>
                    </div>
                }

                @if (!string.IsNullOrEmpty(addMemberSuccess))
                {
                    <div class="add-member-success">
                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" />
                        <span>@addMemberSuccess</span>
                    </div>
                }
            </div>
        </div>
    </div>
}


@code {
    [Parameter] public bool IsEmpty { get; set; } = true;
    [Parameter] public bool IsDirectMessage { get; set; } = true;
    [Parameter] public Guid CurrentUserId { get; set; }
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public Guid? ChannelId { get; set; }

    // Direct Message Parameters
    [Parameter] public List<DirectMessageDto> DirectMessages { get; set; } = new();
    [Parameter] public string RecipientName { get; set; } = string.Empty;
    [Parameter] public string? RecipientAvatarUrl { get; set; }
    [Parameter] public bool IsRecipientOnline { get; set; }

    // Channel Parameters
    [Parameter] public List<ChannelMessageDto> ChannelMessages { get; set; } = new();
    [Parameter] public string ChannelName { get; set; } = string.Empty;
    [Parameter] public string? ChannelDescription { get; set; }
    [Parameter] public ChannelType ChannelType { get; set; }
    [Parameter] public int MemberCount { get; set; }
    [Parameter] public int PinnedCount { get; set; }
    [Parameter] public bool IsChannelAdmin { get; set; }

    // Common Parameters
    [Parameter] public bool IsLoading { get; set; }
    [Parameter] public bool IsLoadingMore { get; set; }
    [Parameter] public bool HasMoreMessages { get; set; }
    [Parameter] public bool IsSending { get; set; }
    [Parameter] public List<string> TypingUsers { get; set; } = new();

    // Event Callbacks
    [Parameter] public EventCallback<string> OnSendMessage { get; set; }
    [Parameter] public EventCallback<(Guid messageId, string content)> OnEditMessage { get; set; }
    [Parameter] public EventCallback<Guid> OnDeleteMessage { get; set; }
    [Parameter] public EventCallback<(Guid messageId, string emoji)> OnAddReaction { get; set; }
    [Parameter] public EventCallback<bool> OnTyping { get; set; }
    [Parameter] public EventCallback OnLoadMore { get; set; }
    [Parameter] public EventCallback OnShowPinnedMessages { get; set; }
    [Parameter] public EventCallback<Guid> OnReply { get; set; }
    [Parameter] public EventCallback<Guid> OnForward { get; set; }
    [Parameter] public EventCallback OnCancelReply { get; set; }
    [Parameter] public EventCallback<(Guid userId, ChannelMemberRole role)> OnAddMember { get; set; }
    [Parameter] public EventCallback<string> OnSearchUsers { get; set; }
    [Parameter] public List<UserDto> UserSearchResults { get; set; } = new();
    [Parameter] public bool IsSearchingUsers { get; set; }

    // Reply state parameters
    [Parameter] public bool IsReplying { get; set; }
    [Parameter] public Guid? ReplyToMessageId { get; set; }
    [Parameter] public string? ReplyToSenderName { get; set; }
    [Parameter] public string? ReplyToContent { get; set; }


    private ElementReference messagesContainerRef;
    private ElementReference scrollAnchorRef;
    private ElementReference loadMoreTriggerRef;
    private MessageInput? messageInputRef;
    private bool showSearch = false;
    private bool showInfoPanel = false;
    private bool showAddMemberPanel = false;
    private string SearchQuery { get; set; } = string.Empty;
    private bool isEditing = false;
    private Guid editingMessageId;
    private string editingContent = string.Empty;
    private int _previousMessageCount;
    private bool _shouldScrollToBottom;
    private bool _isLoadingMore = false;
    private object? _savedScrollPosition = null;
    private DateTime _lastScrollCheck = DateTime.MinValue;
    private int _scrollTopOnLastCheck = 0;

    // Add member panel state
    private string memberSearchQuery = string.Empty;
    private List<UserDto> memberSearchResults = new();
    private bool isSearchingMembers = false;
    private bool isAddingMember = false;
    private Guid? addingUserId = null;
    private string? addMemberError = null;
    private string? addMemberSuccess = null;
    private Dictionary<Guid, ChannelMemberRole> selectedRoleForUser = new();
    private CancellationTokenSource? _memberSearchCts;
    private int _previousChannelMessagesHash = 0;

    protected override void OnParametersSet()
    {
        // Check if new messages were added (but not from load more)
        var currentCount = DirectMessages.Count + ChannelMessages.Count;

        // If this is first time seeing messages (was 0, now > 0), scroll to bottom
        if (_previousMessageCount == 0 && currentCount > 0)
        {
            _shouldScrollToBottom = true;
        }
        // Otherwise, only scroll to bottom if:
        // 1. New messages were added (currentCount increased)
        // 2. NOT from load more operation (detected by _isLoadingMore flag)
        // 3. NOT editing
        // 4. NOT replying
        // 5. The increase is small (1-5 messages = new incoming, not pagination)
        else
        {
            var messageIncrease = currentCount - _previousMessageCount;
            var isNewIncomingMessage = messageIncrease > 0 && messageIncrease <= 5;

            if (isNewIncomingMessage && !_isLoadingMore && !isEditing && !IsReplying)
            {
                _shouldScrollToBottom = true;
            }
        }

        _previousMessageCount = currentCount;

        // Check if ChannelMessages list reference changed
        var currentHash = ChannelMessages.GetHashCode();
        if (currentHash != _previousChannelMessagesHash)
        {
            _previousChannelMessagesHash = currentHash;

            // Force immediate re-render when parameters change
            // This ensures MessageBubble components receive updated parameters like ReadByCount
            InvokeAsync(StateHasChanged);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_isLoadingMore && _savedScrollPosition != null)
        {
            // Wait for DOM to fully render new messages
            await Task.Delay(100);

            // Restore scroll position after loading more messages
            await JS.InvokeVoidAsync("chatAppUtils.restoreScrollPosition", messagesContainerRef, _savedScrollPosition);
            _isLoadingMore = false;
            _savedScrollPosition = null;
        }
        else if (_shouldScrollToBottom)
        {
            _shouldScrollToBottom = false;
            await ScrollToBottomAsync();
        }
        else if (firstRender && (DirectMessages.Any() || ChannelMessages.Any()))
        {
            await ScrollToBottomAsync();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("chatAppUtils.scrollToBottom", messagesContainerRef);
        }
        catch
        {
            // Ignore scroll errors (component may be disposed)
        }
    }


    private IEnumerable<IGrouping<DateTime, DirectMessageDto>> GroupedDirectMessages =>
        DirectMessages
            .OrderBy(m => m.CreatedAtUtc)
            .GroupBy(m => m.CreatedAtUtc.Date);

    private IEnumerable<IGrouping<DateTime, ChannelMessageDto>> GroupedChannelMessages =>
        ChannelMessages
            .OrderBy(m => m.CreatedAtUtc)
            .GroupBy(m => m.CreatedAtUtc.Date);

    private static string GetInitials(string name)
    {
        if (string.IsNullOrWhiteSpace(name)) return "?";
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length >= 2
            ? $"{parts[0][0]}{parts[1][0]}".ToUpper()
            : name[0].ToString().ToUpper();
    }

    private string FormatDateDivider(DateTime date)
    {
        var today = DateTime.UtcNow.Date;
        if (date == today) return "Today";
        if (date == today.AddDays(-1)) return "Yesterday";
        if ((today - date).TotalDays < 7) return date.ToString("dddd");
        return date.ToString("MMMM d, yyyy");
    }

    private string GetInputPlaceholder()
    {
        return IsDirectMessage
            ? $"Message {RecipientName}..."
            : $"Message #{ChannelName}...";
    }

    private bool ShouldShowAvatar(DirectMessageDto message, IEnumerable<DirectMessageDto> messages)
    {
        var list = messages.ToList();
        var index = list.IndexOf(message);
        if (index == 0) return true;
        return list[index - 1].SenderId != message.SenderId;
    }

    private bool ShouldShowChannelAvatar(ChannelMessageDto message, IEnumerable<ChannelMessageDto> messages)
    {
        var list = messages.ToList();
        var index = list.IndexOf(message);
        if (index == 0) return true;
        return list[index - 1].SenderId != message.SenderId;
    }

    private bool ShouldShowSenderName(ChannelMessageDto message, IEnumerable<ChannelMessageDto> messages)
    {
        var list = messages.ToList();
        var index = list.IndexOf(message);
        if (index == 0) return message.SenderId != CurrentUserId;
        if (message.SenderId == CurrentUserId) return false;
        return list[index - 1].SenderId != message.SenderId;
    }

    private void ToggleSearch()
    {
        showSearch = !showSearch;
        if (!showSearch) SearchQuery = string.Empty;
    }

    private void ToggleInfoPanel()
    {
        showInfoPanel = !showInfoPanel;
    }

    private void CloseInfoPanel()
    {
        showInfoPanel = false;
    }

    private async Task TogglePinnedMessages()
    {
        await OnShowPinnedMessages.InvokeAsync();
    }

    private async Task LoadMoreMessages()
    {
        // Save scroll position before loading
        _savedScrollPosition = await JS.InvokeAsync<object>("chatAppUtils.saveScrollPosition", messagesContainerRef);
        _isLoadingMore = true;
        await OnLoadMore.InvokeAsync();
    }

    private async Task SendMessage(string content)
    {
        await OnSendMessage.InvokeAsync(content);
    }

    private void StartEditMessage(Guid messageId, string content)
    {
        isEditing = true;
        editingMessageId = messageId;
        editingContent = content;
        StateHasChanged();
    }

    private async Task EditMessage(string newContent)
    {
        // If content hasn't changed, just cancel - no API call needed
        if (newContent == editingContent)
        {
            CancelEdit();
            return;
        }

        await OnEditMessage.InvokeAsync((editingMessageId, newContent));
        CancelEdit();
    }

    private void CancelEdit()
    {
        isEditing = false;
        editingMessageId = Guid.Empty;
        editingContent = "";
    }

    private async Task DeleteMessage(Guid messageId)
    {
        await OnDeleteMessage.InvokeAsync(messageId);
    }

    private async Task AddReaction(Guid messageId, string emoji)
    {
        await OnAddReaction.InvokeAsync((messageId, emoji));
    }

    private async Task HandleTyping(bool isTyping)
    {
        await OnTyping.InvokeAsync(isTyping);
    }

    private void HandleAttach()
    {
        // File attachment feature not implemented yet
    }

    private async Task RefocusInput()
    {
        // Refocus the textarea after any message action (edit, reply, copy, forward, etc.)
        if (messageInputRef != null)
        {
            await messageInputRef.FocusAsync();
        }
    }

    private async Task PinMessage(Guid messageId)
    {
        // Pin/unpin functionality will be implemented when needed
        await Task.CompletedTask;
    }

    private async Task HandleReplyClick(Guid repliedMessageId)
    {
        try
        {
            // Use querySelector to find the message by ID
            await JS.InvokeVoidAsync("chatAppUtils.scrollToMessageById", $"message-{repliedMessageId}");
        }
        catch
        {
            // Message not loaded yet or element not found
        }
    }

    private async Task HandleScroll()
    {
        // Don't handle scroll during loading or restore
        if (_isLoadingMore || IsLoadingMore)
        {
            return;
        }

        try
        {
            // Get current scroll position
            var scrollTop = await JS.InvokeAsync<int>("chatAppUtils.getScrollTop", messagesContainerRef);

            // Cancel any pending scroll to bottom when user manually scrolls
            if (_shouldScrollToBottom && scrollTop > 0)
            {
                _shouldScrollToBottom = false;
            }

            // Don't proceed if no more messages to load
            if (!HasMoreMessages)
            {
                return;
            }

            // Throttle: Only trigger if scroll position changed significantly and enough time passed
            var now = DateTime.UtcNow;
            var timeSinceLastCheck = (now - _lastScrollCheck).TotalMilliseconds;
            var scrollDifference = Math.Abs(scrollTop - _scrollTopOnLastCheck);

            // Only proceed if:
            // 1. At least 200ms passed since last check
            // 2. Scroll position changed by at least 50px (significant scroll)
            if (timeSinceLastCheck < 200 || scrollDifference < 50)
            {
                return;
            }

            _lastScrollCheck = now;
            _scrollTopOnLastCheck = scrollTop;

            // If scrolled to within 200px of the top, trigger load more
            if (scrollTop < 200)
            {
                await LoadMoreMessages();
            }
        }
        catch
        {
            // Ignore scroll errors
        }
    }

    private async Task HandleChatAreaClick()
    {
        // Refocus the textarea when clicking anywhere in the chat area
        await RefocusInput();
    }

    #region Add Member Panel

    private void ToggleAddMemberPanel()
    {
        showAddMemberPanel = !showAddMemberPanel;
        if (!showAddMemberPanel)
        {
            ResetAddMemberPanel();
        }
    }

    private void CloseAddMemberPanel()
    {
        showAddMemberPanel = false;
        ResetAddMemberPanel();
    }

    private void ResetAddMemberPanel()
    {
        memberSearchQuery = string.Empty;
        memberSearchResults.Clear();
        selectedRoleForUser.Clear();
        addMemberError = null;
        addMemberSuccess = null;
        _memberSearchCts?.Cancel();
    }

    private async Task OnMemberSearchInput(ChangeEventArgs e)
    {
        memberSearchQuery = e.Value?.ToString() ?? "";
        addMemberError = null;
        addMemberSuccess = null;

        // Cancel previous search
        _memberSearchCts?.Cancel();
        _memberSearchCts = new CancellationTokenSource();
        var token = _memberSearchCts.Token;

        // Clear results if query is too short
        if (string.IsNullOrWhiteSpace(memberSearchQuery) || memberSearchQuery.Length < 2)
        {
            memberSearchResults.Clear();
            isSearchingMembers = false;
            StateHasChanged();
            return;
        }

        // Debounce - wait 300ms before searching
        try
        {
            await Task.Delay(300, token);
        }
        catch (TaskCanceledException)
        {
            return;
        }

        await SearchMembers(token);
    }

    private async Task SearchMembers(CancellationToken token)
    {
        if (token.IsCancellationRequested) return;

        isSearchingMembers = true;
        StateHasChanged();

        try
        {
            await OnSearchUsers.InvokeAsync(memberSearchQuery);

            if (token.IsCancellationRequested) return;

            // Copy results from parent and initialize role selections
            memberSearchResults = UserSearchResults.ToList();
            foreach (var user in memberSearchResults)
            {
                if (!selectedRoleForUser.ContainsKey(user.Id))
                {
                    selectedRoleForUser[user.Id] = ChannelMemberRole.Member;
                }
            }
        }
        catch
        {
            memberSearchResults.Clear();
        }
        finally
        {
            if (!token.IsCancellationRequested)
            {
                isSearchingMembers = false;
                StateHasChanged();
            }
        }
    }

    private async Task AddMemberToChannel(Guid userId)
    {
        if (isAddingMember) return;

        isAddingMember = true;
        addingUserId = userId;
        addMemberError = null;
        addMemberSuccess = null;
        StateHasChanged();

        try
        {
            var role = selectedRoleForUser.GetValueOrDefault(userId, ChannelMemberRole.Member);
            await OnAddMember.InvokeAsync((userId, role));

            // Remove from search results after successful add
            var user = memberSearchResults.FirstOrDefault(u => u.Id == userId);
            if (user != null)
            {
                addMemberSuccess = $"{user.DisplayName} added successfully";
                memberSearchResults.Remove(user);
                selectedRoleForUser.Remove(userId);
            }
        }
        catch (Exception ex)
        {
            addMemberError = ex.Message;
        }
        finally
        {
            isAddingMember = false;
            addingUserId = null;
            StateHasChanged();

            // Auto-hide success message after 3 seconds
            if (!string.IsNullOrEmpty(addMemberSuccess))
            {
                _ = Task.Delay(3000).ContinueWith(_ =>
                {
                    InvokeAsync(() =>
                    {
                        addMemberSuccess = null;
                        StateHasChanged();
                    });
                });
            }
        }
    }

    #endregion

    public async ValueTask DisposeAsync()
    {
        _memberSearchCts?.Cancel();
        _memberSearchCts?.Dispose();
        await Task.CompletedTask;
    }
}