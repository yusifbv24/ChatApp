<div class="message-input-container @(IsEditing ? "editing" : "") @(IsReplying ? "replying" : "")">
    @if (IsEditing)
    {
        <div class="edit-indicator">
            <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" />
            <span>Editing message</span>
            <button class="cancel-edit-btn" @onclick="CancelEdit">
                <MudIcon  Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
            </button>
        </div>
    }

    @if (IsReplying && !string.IsNullOrEmpty(ReplyToSenderName))
    {
        <div class="reply-indicator">
            <MudIcon Icon="@Icons.Material.Filled.Reply" Size="Size.Small" />
            <div class="reply-info">
                <span class="reply-to-name">Replying to @ReplyToSenderName</span>
                <span class="reply-to-preview">@TruncateText(ReplyToContent, 60)</span>
            </div>
            <button class="cancel-reply-btn" @onclick="CancelReply">
                <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
            </button>
        </div>
    }

    @if (!UserState.HasPermission("Messages.Send"))
    {
        <div class="input-row disabled-input">
            <div class="permission-denied-message">
                <MudIcon Icon="@Icons.Material.Filled.Lock" Size="Size.Small" />
                <span>You don't have permission to send messages</span>
            </div>
        </div>
    }
    else
    {
        <div class="input-row">
            <button class="input-action-btn attach-btn" title="Attach file" @onclick="OnAttachClick" disabled="@IsSending">
                <MudIcon Icon="@Icons.Material.Filled.AttachFile" />
            </button>

            <div class="input-wrapper">
                <textarea @ref="textAreaRef"
                          class="message-textarea"
                          placeholder="@Placeholder"
                          value="@MessageText"
                          @oninput="HandleInput"
                          @onkeydown="HandleKeyDown"
                          @onfocus="HandleFocus"
                          @onblur="HandleBlur"
                          disabled="@IsSending"
                          rows="1"></textarea>
            </div>

            <button class="input-action-btn emoji-btn" title="Emoji" @onclick="ToggleEmojiPicker" disabled="@IsSending">
                <MudIcon Icon="@Icons.Material.Filled.EmojiEmotions"/>
            </button>

            <button class="send-btn @(CanSend ? "active" : "")"
                    title="@(IsEditing ? "Save" : "Send")"
                    @onclick="SendMessage"
                    disabled="@(!CanSend || IsSending)">
                @if (IsSending)
                {
                    <div class="send-spinner"></div>
                }
                else
                {
                    <MudIcon Icon="@(IsEditing ? Icons.Material.Filled.Check : Icons.Material.Filled.Send)" />
                }
            </button>
        </div>
    }
</div>

<!-- Emoji Picker -->
@if (showEmojiPicker)
{
    <div class="emoji-picker-overlay" @onclick="CloseEmojiPicker">
        <div class="emoji-picker" @onclick:stopPropagation="true">
            <div class="emoji-picker-header">
                <span>Emoji</span>
                <button class="close-picker-btn" @onclick="CloseEmojiPicker">
                    <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
                </button>
            </div>
            <div class="emoji-grid">
                @foreach(var emoji in CommonEmojis)
                {
                    <button class="emoji-btn" @onclick="()=>InsertEmoji(emoji)">@emoji</button>
                }
            </div>
        </div>
    </div>
}

@inject IJSRuntime JS
@inject UserState UserState

@code{
    [Parameter] public string Placeholder { get; set; } = "Type a message...";
    [Parameter] public bool IsEditing { get; set; }
    [Parameter] public string? EditingContent { get; set; }
    [Parameter] public bool IsSending { get; set; }
    [Parameter] public EventCallback<string> OnSend { get; set; }
    [Parameter] public EventCallback<string> OnEdit { get; set; }
    [Parameter] public EventCallback OnCancelEdit { get; set; }
    [Parameter] public EventCallback<bool> OnTyping { get; set; }
    [Parameter] public EventCallback OnAttach { get; set; }
    [Parameter] public Guid? ConversationId { get; set; }

    // Reply-related parameters
    [Parameter] public bool IsReplying { get; set; }
    [Parameter] public Guid? ReplyToMessageId { get; set; }
    [Parameter] public string? ReplyToSenderName { get; set; }
    [Parameter] public string? ReplyToContent { get; set; }
    [Parameter] public EventCallback OnCancelReply { get; set; }

    private ElementReference textAreaRef;
    private string MessageText { get; set; } = "";
    private bool showEmojiPicker=false;
    private bool isTyping = false;
    private System.Timers.Timer? typingTimer;
    private Guid? previousConversationId;
    private bool wasEditing = false;
    private bool wasReplying = false;

    private readonly string[] CommonEmojis = {

        "😀", "😃", "😄", "😁", "😅", "😂", "🤣", "😊",

        "😇", "🙂", "🙃", "😉", "😌", "😍", "🥰", "😘",

        "😗", "😙", "😚", "😋", "😛", "😜", "🤪", "😝",

        "🤑", "🤗", "🤭", "🤫", "🤔", "🤐", "🤨", "😐",

        "👍", "👎", "👌", "✌️", "🤞", "🤟", "🤘", "🤙",

        "👏", "🙌", "👐", "🤲", "🤝", "🙏", "❤️", "🧡",

        "💛", "💚", "💙", "💜", "🖤", "💔", "💕", "💞",

        "🎉", "🎊", "🎁", "🔥", "⭐", "✨", "💯", "💪"

    };

    private bool CanSend => !string.IsNullOrWhiteSpace(MessageText) && !IsSending;
    private bool shouldFocus = false;

    protected override void OnInitialized()
    {
        typingTimer = new System.Timers.Timer(2000);
        typingTimer.Elapsed += async (s, e) => await StopTyping();
        typingTimer.AutoReset=false;
    }

    protected override void OnParametersSet()
    {
        // Handle editing mode
        if(IsEditing && !string.IsNullOrEmpty(EditingContent))
        {
            MessageText = EditingContent;
            wasEditing = true;
        }
        else if (wasEditing && !IsEditing)
        {
            // Editing was cancelled or completed - clear the text
            MessageText = "";
            wasEditing = false;
        }

        // Handle reply mode - auto-focus when replying starts
        if (IsReplying && !wasReplying)
        {
            shouldFocus = true;
            wasReplying = true;
        }
        else if (!IsReplying && wasReplying)
        {
            wasReplying = false;
        }

        // Focus when conversation changes
        if (ConversationId != previousConversationId)
        {
            previousConversationId = ConversationId;
            shouldFocus = true;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldFocus || firstRender)
        {
            shouldFocus = false;
            try
            {
                await textAreaRef.FocusAsync();
            }
            catch
            {
                // Element may not be available yet
            }
        }
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        MessageText = e.Value?.ToString() ?? "";
        await StartTyping();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if(e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task HandleFocus()
    {
        // Focus handling if needed
        await Task.CompletedTask;
    }

    private async Task HandleBlur()
    {
        await StopTyping();
    }

    private async Task StartTyping()
    {
        if (!isTyping)
        {
            isTyping = true;
            await OnTyping.InvokeAsync(true);
        }
        typingTimer?.Stop();
        typingTimer?.Start();
    }

    private async Task StopTyping()
    {
        if (isTyping)
        {
            isTyping = false;
            await InvokeAsync(async () => await OnTyping.InvokeAsync(false));
        }
    }

    private async Task SendMessage()
    {
        if (!CanSend) return;

        var message = MessageText.Trim();
        MessageText = "";
        await StopTyping();

        if (IsEditing)
        {
            await OnEdit.InvokeAsync(message);
        }
        else
        {
            await OnSend.InvokeAsync(message);
        }

        // Re-focus after sending message
        shouldFocus = true;
        StateHasChanged();
    }

    private async Task CancelEdit()
    {
        MessageText = "";
        await OnCancelEdit.InvokeAsync();
    }

    private async Task CancelReply()
    {
        await OnCancelReply.InvokeAsync();
    }

    private string TruncateText(string? text, int maxLength)
    {
        if (string.IsNullOrEmpty(text)) return "";
        if (text.Length <= maxLength) return text;
        return text.Substring(0, maxLength) + "...";
    }

    private async Task OnAttachClick()
    {
        await OnAttach.InvokeAsync();
    }

    private void ToggleEmojiPicker()
    {
        showEmojiPicker = !showEmojiPicker;
    }

    private void CloseEmojiPicker()
    {
        showEmojiPicker = false;
    }

    private void InsertEmoji(string emoji)
    {
        MessageText += emoji;
        showEmojiPicker = false;
    }

    public void Dispose()
    {
        typingTimer?.Dispose();
    }
}