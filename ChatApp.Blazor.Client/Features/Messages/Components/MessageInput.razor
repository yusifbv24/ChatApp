@inject IJSRuntime JS
@inject UserState UserState

<div class="message-input-container @(IsEditing ? "editing" : "") @(IsReplying ? "replying" : "")">
    @if (IsEditing)
    {
        <div class="edit-indicator">
            <MudIcon Icon="@Icons.Material.Filled.Edit" Size="Size.Small" />
            <span>Editing message</span>
            <button class="cancel-edit-btn" @onclick="CancelEdit">
                <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
            </button>
        </div>
    }

    @if (IsReplying && !string.IsNullOrEmpty(ReplyToSenderName))
    {
        <div class="reply-indicator">
            <MudIcon Icon="@Icons.Material.Filled.Reply" Size="Size.Small" />
            <div class="reply-info">
                <span class="reply-to-name">Replying to @ReplyToSenderName</span>
                <span class="reply-to-preview">@TruncateText(ReplyToContent, 60)</span>
            </div>
            <button class="cancel-reply-btn" @onclick="CancelReply">
                <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
            </button>
        </div>
    }

    @if (!UserState.HasPermission("Messages.Send"))
    {
        <div class="input-bubble disabled-input">
            <div class="permission-denied-message">
                <MudIcon Icon="@Icons.Material.Filled.Lock" Size="Size.Small" />
                <span>You don't have permission to send messages</span>
            </div>
        </div>
    }
    else
    {
        <div class="input-bubble">
            <button class="input-icon-btn attach-btn" title="Attach file" @onclick="OnAttachClick" disabled="@IsSending">
                <MudIcon Icon="@Icons.Material.Filled.AttachFile" Size="Size.Small" />
            </button>

            <textarea @ref="textAreaRef"
                      class="message-textarea"
                      placeholder="@Placeholder"
                      value="@MessageText"
                      @oninput="HandleInput"
                      @onkeydown="HandleKeyDown"
                      @onblur="HandleBlur"
                      disabled="@IsSending"
                      maxlength="4000"
                      rows="1"></textarea>

            <span class="char-counter @(IsNearLimit ? "near-limit" : "") @(IsAtLimit ? "at-limit" : "")">
                @MessageText.Length/@MaxLength
            </span>

            <button class="input-icon-btn emoji-btn" title="Emoji" @onclick="ToggleEmojiPicker" disabled="@IsSending">
                <MudIcon Icon="@Icons.Material.Filled.EmojiEmotions" Size="Size.Small" />
            </button>

            <button class="send-btn @(CanSend ? "active" : "")"
                    title="@(IsEditing ? "Save" : "Send")"
                    @onclick="SendMessage"
                    disabled="@SendButtonDisabled">
                @if (IsSending)
                {
                    <div class="send-spinner"></div>
                }
                else
                {
                    <MudIcon Icon="@(IsEditing ? Icons.Material.Filled.Check : Icons.Material.Filled.Send)" Size="Size.Small" />
                }
            </button>
        </div>
    }
</div>

<!-- Emoji Picker -->
@if (showEmojiPicker)
{
    <div class="emoji-picker-overlay" @onclick="CloseEmojiPicker">
        <div class="emoji-picker" @onclick:stopPropagation="true">
            <div class="emoji-picker-header">
                <span>Emoji</span>
                <button class="close-picker-btn" @onclick="CloseEmojiPicker">
                    <MudIcon Icon="@Icons.Material.Filled.Close" Size="Size.Small" />
                </button>
            </div>
            <div class="emoji-grid">
                @foreach (var emoji in CommonEmojis)
                {
                    <button class="emoji-btn" @onclick="() => InsertEmoji(emoji)">@emoji</button>
                }
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public string Placeholder { get; set; } = "Type a message...";
    [Parameter] public bool IsEditing { get; set; }
    [Parameter] public string? EditingContent { get; set; }
    [Parameter] public bool IsSending { get; set; }
    [Parameter] public EventCallback<string> OnSend { get; set; }
    [Parameter] public EventCallback<string> OnEdit { get; set; }
    [Parameter] public EventCallback OnCancelEdit { get; set; }
    [Parameter] public EventCallback<bool> OnTyping { get; set; }
    [Parameter] public EventCallback OnAttach { get; set; }
    [Parameter] public Guid? ConversationId { get; set; }

    // Reply-related parameters
    [Parameter] public bool IsReplying { get; set; }
    [Parameter] public string? ReplyToSenderName { get; set; }
    [Parameter] public string? ReplyToContent { get; set; }
    [Parameter] public EventCallback OnCancelReply { get; set; }

    // Draft support
    [Parameter] public string? InitialDraft { get; set; }
    [Parameter] public EventCallback<string> OnDraftChanged { get; set; }

    private const int MaxLength = 4000;
    private ElementReference textAreaRef;
    private string MessageText { get; set; } = string.Empty;
    private bool showEmojiPicker = false;
    private bool isTyping = false;
    private System.Timers.Timer? typingTimer;
    private Guid? previousConversationId;
    private bool wasEditing = false;
    private bool wasReplying = false;

    private readonly string[] CommonEmojis = {
        "ðŸ˜€", "ðŸ˜ƒ", "ðŸ˜„", "ðŸ˜", "ðŸ˜…", "ðŸ˜‚", "ðŸ¤£", "ðŸ˜Š",
        "ðŸ˜‡", "ðŸ™‚", "ðŸ™ƒ", "ðŸ˜‰", "ðŸ˜Œ", "ðŸ˜", "ðŸ¥°", "ðŸ˜˜",
        "ðŸ˜—", "ðŸ˜™", "ðŸ˜š", "ðŸ˜‹", "ðŸ˜›", "ðŸ˜œ", "ðŸ¤ª", "ðŸ˜",
        "ðŸ¤‘", "ðŸ¤—", "ðŸ¤­", "ðŸ¤«", "ðŸ¤”", "ðŸ¤", "ðŸ¤¨", "ðŸ˜",
        "ðŸ‘", "ðŸ‘Ž", "ðŸ‘Œ", "âœŒï¸", "ðŸ¤ž", "ðŸ¤Ÿ", "ðŸ¤˜", "ðŸ¤™",
        "ðŸ‘", "ðŸ™Œ", "ðŸ‘", "ðŸ¤²", "ðŸ¤", "ðŸ™", "â¤ï¸", "ðŸ§¡",
        "ðŸ’›", "ðŸ’š", "ðŸ’™", "ðŸ’œ", "ðŸ–¤", "ðŸ’”", "ðŸ’•", "ðŸ’ž",
        "ðŸŽ‰", "ðŸŽŠ", "ðŸŽ", "ðŸ”¥", "â­", "âœ¨", "ðŸ’¯", "ðŸ’ª"
    };

    private bool CanSend => !string.IsNullOrWhiteSpace(MessageText) && !IsSending && MessageText.Length <= MaxLength;
    private bool SendButtonDisabled => !CanSend || IsSending;
    private bool IsNearLimit => MessageText.Length >= 3500 && MessageText.Length < MaxLength;
    private bool IsAtLimit => MessageText.Length >= MaxLength;
    private bool shouldFocus = false;

    protected override void OnInitialized()
    {
        typingTimer = new System.Timers.Timer(2000);
        typingTimer.Elapsed += async (s, e) => await StopTyping();
        typingTimer.AutoReset = false;
    }

    protected override async Task OnParametersSetAsync()
    {
        // Handle editing mode - only set content when editing STARTS (not every render)
        if (IsEditing && !wasEditing && !string.IsNullOrEmpty(EditingContent))
        {
            MessageText = EditingContent;
            wasEditing = true;
            shouldFocus = true;
        }
        else if (wasEditing && !IsEditing)
        {
            // Editing was cancelled or completed - clear the text and reset textarea height
            MessageText = string.Empty;
            wasEditing = false;

            // Reset textarea height to normal (1 row)
            try
            {
                await JS.InvokeVoidAsync("chatAppUtils.resetTextareaHeight", textAreaRef);
            }
            catch
            {
                // JS interop may fail if element not available
            }
        }

        // Handle reply mode - auto-focus when replying starts
        if (IsReplying && !wasReplying)
        {
            shouldFocus = true;
            wasReplying = true;
        }
        else if (!IsReplying && wasReplying)
        {
            wasReplying = false;
        }

        // Focus when conversation changes and load draft
        if (ConversationId != previousConversationId)
        {
            previousConversationId = ConversationId;
            shouldFocus = true;

            // Load the initial draft for this conversation (only on conversation change)
            MessageText = InitialDraft ?? string.Empty;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldFocus || firstRender)
        {
            shouldFocus = false;
            try
            {
                await textAreaRef.FocusAsync();
            }
            catch
            {
                // Element may not be available yet
            }
        }
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        var newValue = e.Value?.ToString() ?? "";

        // Enforce max length
        if (newValue.Length > MaxLength)
        {
            newValue = newValue.Substring(0, MaxLength);
        }

        MessageText = newValue;

        // Close emoji picker when typing
        if (showEmojiPicker)
        {
            showEmojiPicker = false;
        }

        // Send typing indicator for both new messages AND editing
        await StartTyping();

        // Auto-resize textarea
        await JS.InvokeVoidAsync("chatAppUtils.autoResizeTextarea", textAreaRef);

        // Notify parent about draft change (for persistence)
        await OnDraftChanged.InvokeAsync(newValue);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            // Close emoji picker if open
            if (showEmojiPicker)
            {
                showEmojiPicker = false;
            }
            await SendMessage();
        }
        else if (e.Key == "Escape")
        {
            // Close emoji picker with Escape key
            if (showEmojiPicker)
            {
                showEmojiPicker = false;
            }
        }
    }

    private async Task HandleBlur()
    {
        await StopTyping();
    }

    private async Task StartTyping()
    {
        if (!isTyping)
        {
            isTyping = true;
            await OnTyping.InvokeAsync(true);
        }
        typingTimer?.Stop();
        typingTimer?.Start();
    }

    private async Task StopTyping()
    {
        if (isTyping)
        {
            isTyping = false;
            await InvokeAsync(async () => await OnTyping.InvokeAsync(false));
        }
    }

    private async Task SendMessage()
    {
        if (!CanSend) return;

        // Close emoji picker if open
        if (showEmojiPicker)
        {
            showEmojiPicker = false;
        }

        var message = MessageText.Trim();
        MessageText = string.Empty;
        await StopTyping();

        // Clear draft when message is sent
        await OnDraftChanged.InvokeAsync(string.Empty);

        // Reset textarea height
        await JS.InvokeVoidAsync("chatAppUtils.resetTextareaHeight", textAreaRef);

        if (IsEditing)
        {
            await OnEdit.InvokeAsync(message);
        }
        else
        {
            await OnSend.InvokeAsync(message);
        }

        // Re-focus after sending message
        shouldFocus = true;
        StateHasChanged();
    }

    private async Task CancelEdit()
    {
        MessageText = string.Empty;
        await OnCancelEdit.InvokeAsync();
    }

    private async Task CancelReply()
    {
        await OnCancelReply.InvokeAsync();
    }

    private string TruncateText(string? text, int maxLength)
    {
        if (string.IsNullOrEmpty(text)) return "";
        if (text.Length <= maxLength) return text;
        return text.Substring(0, maxLength) + "...";
    }

    private async Task OnAttachClick()
    {
        await OnAttach.InvokeAsync();
    }

    private async Task ToggleEmojiPicker()
    {
        showEmojiPicker = !showEmojiPicker;

        // Keep textarea focused when emoji picker opens
        if (showEmojiPicker)
        {
            shouldFocus = true;
            StateHasChanged();
            await Task.Delay(10);
            await FocusAsync();
        }
    }

    private void CloseEmojiPicker()
    {
        showEmojiPicker = false;
    }

    private async Task InsertEmoji(string emoji)
    {
        // Check if adding emoji would exceed limit
        if (MessageText.Length + emoji.Length <= MaxLength)
        {
            MessageText += emoji;
        }

        // Keep textarea focused after inserting emoji
        await FocusAsync();
    }

    // Public method to focus the textarea from parent components
    public async Task FocusAsync()
    {
        try
        {
            await textAreaRef.FocusAsync();
        }
        catch
        {
            // Element may not be available yet
        }
    }

    public void Dispose()
    {
        typingTimer?.Dispose();
    }
}
